/*
 Navicat MySQL Data Transfer

 Source Server         : root-19921023wr@120.79.75.27
 Source Server Type    : MySQL
 Source Server Version : 50720
 Source Host           : 120.79.75.27
 Source Database       : myblog

 Target Server Type    : MySQL
 Target Server Version : 50720
 File Encoding         : utf-8

 Date: 07/07/2018 15:14:26 PM
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `t_blog`
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL,
  `commendable` bit(1) NOT NULL,
  `content` longtext,
  `create_time` datetime DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommended` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `visits` int(11) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `first_picture_show` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`),
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`),
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`),
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=72 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_blog`
-- ----------------------------
BEGIN;
INSERT INTO `t_blog` VALUES ('4', b'1', b'1', '## 1. 后台启动jar 包\r\n```bash\r\nnohup java -jar myblog-backend-0.0.1-SNAPSHOT.jar &\r\n```\r\n##  2.查看跑的任务\r\n```bash\r\njobs\r\n```\r\n## 3.fg+编号,可把任务调到前台,进而手工停止程序\r\n```bash\r\nfg 1\r\n```\r\n## 4.查看端口占用\r\n```bash\r\nlsof -i:80\r\n```\r\n## 5.查看指定端口TCP连接数,比如下面是查看SSH连接数\r\n```bash\r\nnetstat -nat|grep -i \"22\"|wc -l\r\n```\r\n\r\n\r\n', '2017-12-30 00:31:32', 'Linux在日常代码开发中的常用命令，后面会不断补充地', 'http://www.embeddedlinux.org.cn/uploads/allimg/161126/09402TF4-6.jpg', '原创', b'1', b'1', b'1', 'Linux常用命令', '2017-12-30 16:24:08', '126', '8', '1', b'0'), ('8', b'1', b'1', '```java\r\npackage com.huawei.l00379880.mylib.encrypt;\r\n\r\nimport sun.misc.BASE64Decoder;\r\nimport sun.misc.BASE64Encoder;\r\n\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.DESKeySpec;\r\nimport java.io.IOException;\r\nimport java.security.SecureRandom;\r\n\r\n/***********************************************************\r\n * @Description : 加密和解密算法,用于密码读取\r\n * @author      : l00379880 梁山广\r\n * @date        : 2017/7/20 9:38\r\n * @version     : V1.0\r\n ***********************************************************/\r\n\r\n\r\npublic class EncryptAndDeEncrypt {\r\n\r\n    private final static String DES = \"DES\";\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        String data = \"123 456\";//待加密的算法\r\n        String key = \"liang!@#$%\";//要知道这个key就能解密\r\n        System.err.println(encrypt(data, key));\r\n        System.err.println(decrypt(encrypt(data, key), key));\r\n    }\r\n\r\n    /**\r\n     * Description 根据键值进行加密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    public static String encrypt(String data, String key) throws Exception {\r\n        byte[] bt = encrypt(data.getBytes(), key.getBytes());\r\n        String strs = new BASE64Encoder().encode(bt);\r\n        return strs;\r\n    }\r\n\r\n    /**\r\n     * Description 根据键值进行解密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws IOException\r\n     * @throws Exception\r\n     */\r\n    public static String decrypt(String data, String key) throws IOException,\r\n            Exception {\r\n        if (data == null) {\r\n            return null;\r\n        }\r\n        BASE64Decoder decoder = new BASE64Decoder();\r\n        byte[] buf = decoder.decodeBuffer(data);\r\n        byte[] bt = decrypt(buf, key.getBytes());\r\n        return new String(bt);\r\n    }\r\n	/**\r\n     * Description 根据键值进行加密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    private static byte[] encrypt(byte[] data, byte[] key) throws Exception {\r\n        // 生成一个可信任的随机数源\r\n        SecureRandom sr = new SecureRandom();\r\n\r\n        // 从原始密钥数据创建DESKeySpec对象\r\n        DESKeySpec dks = new DESKeySpec(key);\r\n\r\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\r\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\r\n        SecretKey securekey = keyFactory.generateSecret(dks);\r\n\r\n        // Cipher对象实际完成加密操作\r\n        Cipher cipher = Cipher.getInstance(DES);\r\n\r\n        // 用密钥初始化Cipher对象\r\n        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);\r\n\r\n        return cipher.doFinal(data);\r\n    }\r\n\r\n\r\n    /**\r\n     * Description 根据键值进行解密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    private static byte[] decrypt(byte[] data, byte[] key) throws Exception {\r\n        // 生成一个可信任的随机数源\r\n        SecureRandom sr = new SecureRandom();\r\n\r\n        // 从原始密钥数据创建DESKeySpec对象\r\n        DESKeySpec dks = new DESKeySpec(key);\r\n\r\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\r\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\r\n        SecretKey securekey = keyFactory.generateSecret(dks);\r\n\r\n        // Cipher对象实际完成解密操作\r\n        Cipher cipher = Cipher.getInstance(DES);\r\n\r\n        // 用密钥初始化Cipher对象\r\n        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);\r\n\r\n        return cipher.doFinal(data);\r\n    }\r\n}\r\n```', '2017-12-30 19:46:56', '加密和解密算法,基于JDK自带的BASE64算法，一般用于密码读取', 'https://deeplearning4j.org/img/mnist_render.png', '原创', b'1', b'1', b'1', 'Java实现BASE64加密', '2017-12-30 20:18:29', '41', '1', '1', b'1'), ('10', b'1', b'1', '```java\r\n/***********************************************************\r\n* @Title       : MyFile.java\r\n* @Package     : lsg.huawei.file\r\n* @Description : 最常用的文件操作，关键在于读取中文没问题！！\r\n* @author      : l00379880 梁山广\r\n* @date        : 2016-12-9 上午08:35:06\r\n* @version     : V1.0\r\n***********************************************************/\r\npackage com.huawei.l00379880.mylib.file;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.TreeSet;\r\n\r\n/***********************************************************\r\n * @ClassName   : MyFile\r\n * @Description : TODO(这里用一句话描述这个类的作用)\r\n * @author      : l00379880 梁山广\r\n * @date        : 2016-12-9 上午08:35:06\r\n ***********************************************************/\r\npublic class MyFile\r\n{\r\n	public static ArrayList<String> readFilesUnderFolder(String filepath,String suffix)	\r\n	{\r\n		ArrayList<String> filePathList = new ArrayList<String>();\r\n		File file = new File(filepath);\r\n		if (!file.isDirectory())\r\n		{\r\n			System.out.println(\"输入参数必须是一个文件夹的路径！\");\r\n\r\n		} else if (file.isDirectory())\r\n		{\r\n			String[] filelist = file.list();\r\n			for (int i = 0; i < filelist.length; i++)\r\n			{\r\n				File readfile = new File(filepath + \"\\\\\" + filelist[i]);\r\n				if (!readfile.isDirectory())// 只处理是文件的路径,是文件夹的涉及到下面的递归查找了，后面单独实现\r\n				{\r\n					String totalPath=readfile.getAbsolutePath();\r\n//					System.out.println(totalPath);\r\n					String baseName = readfile.getName();\r\n					if(baseName.endsWith(suffix))\r\n					{\r\n						filePathList.add(totalPath);\r\n					}\r\n				}\r\n			}\r\n		}\r\n		return filePathList;\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readFilesUnderFolderCursively\r\n	* @Description: 递归查找指定路径下指定后缀的所有文件\r\n	* @param      : @param filepath\r\n	* @param      : @param suffix\r\n	* @param      : @return\r\n	* @return     ：  ArrayList<String> 返回类型 ：\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 下午11:31:41\r\n	*************************************************************/\r\n	public static ArrayList<String> readFilesUnderFolderCursively(String filepath,String suffix)//先写文件再读文件就好了\r\n	{\r\n		ArrayList<String> filePathList = new ArrayList<String>();\r\n		readFilesUnderFolderCursivelySon(filepath,suffix);\r\n		filePathList =readLineStrings(System.getProperty(\"user.dir\")+\"\\\\temp.txt\");\r\n		delete(System.getProperty(\"user.dir\")+\"\\\\temp.txt\");\r\n		return filePathList;\r\n	}\r\n	public static ArrayList<String> readFilesUnderFolderCursively(String filepath,String suffix,String encoding)//先写文件再读文件就好了\r\n	{\r\n		ArrayList<String> filePathList = new ArrayList<String>();\r\n		System.out.println(filepath);\r\n		readFilesUnderFolderCursivelySon(filepath,suffix,encoding);\r\n\r\n		filePathList =readLineStrings(System.getProperty(\"user.dir\")+\"\\\\temp.txt\",encoding);\r\n		delete(System.getProperty(\"user.dir\")+\"\\\\temp.txt\");\r\n		return filePathList;\r\n	}\r\n	 /**\r\n     * 读取某个文件夹下的所有指定后缀类型的文件，递归查找,因为每一次递归都会重新创建一个list，所以只能靠引用传值\r\n     */\r\n	public static void readFilesUnderFolderCursivelySon(String filepath,String suffix)\r\n	{\r\n		File file = new File(filepath);\r\n		if (!file.isDirectory())\r\n		{\r\n			System.out.println(\"输入参数必须是一个文件夹的路径！\");\r\n\r\n		} else if (file.isDirectory())\r\n		{\r\n			String[] filelist = file.list();\r\n			for (int i = 0; i < filelist.length; i++)\r\n			{\r\n				File readfile = new File(filepath + \"\\\\\" + filelist[i]);\r\n				if (!readfile.isDirectory())//如果是路径的话\r\n				{\r\n					String totalPath=readfile.getAbsolutePath();\r\n					if(totalPath.endsWith(suffix))\r\n					{\r\n//						System.out.println(totalPath);\r\n						fileAppend(System.getProperty(\"user.dir\")+\"\\\\temp.txt\", \"GBK\", totalPath);//追加要用GBK才能写入中文哦！！\r\n					}\r\n\r\n				} else if (readfile.isDirectory())\r\n				{\r\n					readFilesUnderFolderCursivelySon(filepath + \"\\\\\" + filelist[i], suffix);//递归查找\r\n				}\r\n			}\r\n\r\n		}\r\n	}\r\n	/**\r\n     * 读取某个文件夹下的所有指定后缀类型的文件，递归查找,因为每一次递归都会重新创建一个list，所以只能靠引用传值\r\n     */\r\n	public static void readFilesUnderFolderCursivelySon(String filepath,String suffix,String encoding)\r\n	{\r\n		File file = new File(filepath);\r\n		if (!file.isDirectory())\r\n		{\r\n			System.out.println(\"输入参数必须是一个文件夹的路径！\");\r\n\r\n		} else if (file.isDirectory())\r\n		{\r\n			String[] filelist = file.list();\r\n			for (int i = 0; i < filelist.length; i++)\r\n			{\r\n				File readfile = new File(filepath + \"\\\\\" + filelist[i]);\r\n				if (!readfile.isDirectory())//如果是路径的话\r\n				{\r\n					String totalPath=readfile.getAbsolutePath();\r\n					if(totalPath.endsWith(suffix))\r\n					{\r\n//						System.out.println(totalPath);\r\n						fileAppend(System.getProperty(\"user.dir\")+\"\\\\temp.txt\", encoding, totalPath);//追加要用GBK才能写入中文哦！！\r\n					}\r\n\r\n				} else if (readfile.isDirectory())\r\n				{\r\n					readFilesUnderFolderCursivelySon(filepath + \"\\\\\" + filelist[i], suffix);//递归查找\r\n				}\r\n			}\r\n\r\n		}\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readLineStrings\r\n	* @Description: 按行从文件中读取内容到字符串list\r\n	* @param      : @param filePath\r\n	* @param      : @return\r\n	* @return     ：  ArrayList<String> 返回从文件中督导的字符串list\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-9 上午08:36:14\r\n	*************************************************************/\r\n	public static ArrayList<String> readLineStrings(String filePath)\r\n	{\r\n		ArrayList<String> list=new ArrayList<String>();\r\n		String str = \"\";\r\n		FileInputStream fis = null;\r\n		InputStreamReader isr = null;\r\n		BufferedReader br = null; // 用于包装InputStreamReader,提高处理性能。因为BufferedReader有缓冲的，而InputStreamReader没有。\r\n		try\r\n		{\r\n			fis = new FileInputStream(filePath);// FileInputStream\r\n			// 从文件系统中的某个文件中获取字节\r\n			isr = new InputStreamReader(fis,\"UTF-8\");// InputStreamReader 是字节流通向字符流的桥梁,\r\n			br = new BufferedReader(isr);// 从字符输入流中读取文件中的内容,封装了一个new\r\n											// InputStreamReader的对象\r\n			while ((str = br.readLine()) != null)\r\n			{\r\n				list.add(str);\r\n			}\r\n		} catch (FileNotFoundException e)\r\n		{\r\n		System.out.println(\"找不到指定文件\");\r\n\r\n	} catch (IOException e)\r\n	{\r\n		System.out.println(\"读取文件失败\");\r\n	} finally\r\n	{\r\n		try\r\n		{\r\n			br.close();\r\n			isr.close();\r\n			fis.close();\r\n			// 关闭的时候最好按照先后顺序关闭最后开的先关闭所以先关s,再关n,最后关m\r\n		} catch (IOException e)\r\n		{\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n	return list;//返回list\r\n}\r\n/*************************************************************\r\n* @Title      : readLineStrings\r\n* @Description: 按照指定的编码格式从文件中逐行读入数据到List，重载了一种方式\r\n* @param      : @param filePath\r\n* @param      : @param encoding:指定的编码格式\r\n* @param      : @return\r\n* @return     ：  ArrayList<String> 返回类型\r\n* @author     : l00379880 梁山广\r\n* @date       : 2016年12月17日 下午11:29:04\r\n*************************************************************/\r\npublic static ArrayList<String> readLineStrings(String filePath,String encoding)\r\n{\r\n	ArrayList<String> list=new ArrayList<String>();\r\n	String str = \"\";\r\n	FileInputStream fis = null;\r\n	InputStreamReader isr = null;\r\n	BufferedReader br = null; // 用于包装InputStreamReader,提高处理性能。因为BufferedReader有缓冲的，而InputStreamReader没有。\r\n	try\r\n	{\r\n		fis = new FileInputStream(filePath);// FileInputStream\r\n		// 从文件系统中的某个文件中获取字节\r\n		isr = new InputStreamReader(fis,encoding);// InputStreamReader 是字节流通向字符流的桥梁,\r\n		br = new BufferedReader(isr);// 从字符输入流中读取文件中的内容,封装了一个new\r\n										// InputStreamReader的对象\r\n		while ((str = br.readLine()) != null)\r\n		{\r\n			list.add(str);\r\n		}\r\n	} catch (FileNotFoundException e)\r\n	{\r\n		System.out.println(\"找不到指定文件\");\r\n\r\n	} catch (IOException e)\r\n	{\r\n		System.out.println(\"读取文件失败\");\r\n	} finally\r\n	{\r\n		try\r\n		{\r\n			br.close();\r\n			isr.close();\r\n			fis.close();\r\n			// 关闭的时候最好按照先后顺序关闭最后开的先关闭所以先关s,再关n,最后关m\r\n		} catch (IOException e)\r\n		{\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n	return list;//返回list\r\n}\r\n/*************************************************************\r\n	* @Title      : readLineStringsSet\r\n	* @Description: 从文件中读取数据到集合set中，方便后面进行集合的运算\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding\r\n	* @param      : @return\r\n	* @return     ：  TreeSet<String> 返回类型 ：rb文件的路径集合\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016年12月22日 下午2:00:53\r\n	*************************************************************/\r\n	public static TreeSet<String> readLineStringsSet(String filePath,String encoding)\r\n	{\r\n		 TreeSet<String> set=new TreeSet<String>();\r\n		String str = \"\";\r\n		FileInputStream fis = null;\r\n		InputStreamReader isr = null;\r\n		BufferedReader br = null; // 用于包装InputStreamReader,提高处理性能。因为BufferedReader有缓冲的，而InputStreamReader没有。\r\n		try\r\n		{\r\n			fis = new FileInputStream(filePath);// FileInputStream\r\n			// 从文件系统中的某个文件中获取字节\r\n			isr = new InputStreamReader(fis,encoding);// InputStreamReader 是字节流通向字符流的桥梁,\r\n			br = new BufferedReader(isr);// 从字符输入流中读取文件中的内容,封装了一个new\r\n											// InputStreamReader的对象\r\n			while ((str = br.readLine()) != null)\r\n			{\r\n				set.add(str);\r\n			}\r\n		} catch (FileNotFoundException e)\r\n		{\r\n			System.out.println(\"找不到指定文件\");\r\n\r\n		} catch (IOException e)\r\n		{\r\n			System.out.println(\"读取文件失败\");\r\n		} finally\r\n		{\r\n			try\r\n			{\r\n				br.close();\r\n				isr.close();\r\n				fis.close();\r\n				// 关闭的时候最好按照先后顺序关闭最后开的先关闭所以先关s,再关n,最后关m\r\n			} catch (IOException e)\r\n			{\r\n				e.printStackTrace();\r\n			}\r\n		}\r\n		return set;//返回list\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readAlltoHTML\r\n	* @Description: 把文本文件中的全部内容读取到一个StringBuilder中\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016年12月20日 下午8:43:00\r\n	*************************************************************/\r\n	public static String readAlltoHTML(String filePath,String encoding)\r\n	{\r\n		StringBuilder result = new StringBuilder(\"\");//新建结果字符串\r\n		ArrayList<String> contentLines = readLineStrings(filePath, encoding);//把脚本文件读取过来\r\n		for(String line:contentLines)\r\n		{\r\n			result.append(line+\"<br>\");\r\n		}\r\n		return result.toString();\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readAll\r\n	* @Description: 一次性把文件内容都读到一个ts文件夹\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年2月13日 下午7:35:19\r\n	*************************************************************/\r\n	public static String readAll(String filePath,String encoding)\r\n	{\r\n		StringBuilder result = new StringBuilder(\"\");//新建结果字符串\r\n		ArrayList<String> contentLines = readLineStrings(filePath, encoding);//把脚本文件读取过来\r\n		for(String line:contentLines)\r\n		{\r\n			result.append(line+\"\\n\");\r\n		}\r\n		return result.toString();\r\n	}\r\n	/*************************************************************\r\n	* @Title      : fileAppend\r\n	* @Description: 向文件中追加内容，删除需要自己额外操作\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding：最好用UTF-8模式\r\n	* @param      : @param content\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 下午11:21:52\r\n	*************************************************************/\r\n	public static void fileAppend(String filePath,String encoding,String content)\r\n	{\r\n		BufferedWriter out = null;\r\n		try\r\n		{\r\n			out = new BufferedWriter(new OutputStreamWriter(\r\n					new FileOutputStream(filePath, true),encoding));\r\n			out.write(content + \"\\r\\n\");\r\n		} catch (Exception e)\r\n		{\r\n			e.printStackTrace();\r\n		} finally\r\n		{\r\n			try\r\n			{\r\n				out.close();\r\n			} catch (IOException e)\r\n			{\r\n				e.printStackTrace();\r\n			}\r\n		}\r\n\r\n	}\r\n\r\n	/*************************************************************\r\n	* @Title      : fileWrite\r\n	* @Description: 向文件中写入自定义内容，兼容中文，如果文件原来存在\r\n	*               会先删除的，适合一次性写入日志\r\n	* @param      : @param filePath 文件路径\r\n	* @param      : @param encoding 编码\r\n	* @param      : @param content  待写入的内容\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-8 下午11:00:12\r\n	*************************************************************/\r\npublic static void fileWrite(String filePath,String encoding,String content)\r\n	{\r\n		File file = new File(filePath);\r\n		if(file.exists())\r\n		{\r\n			file.delete();//结果文件存在的话先删除，适合写入日志\r\n		}\r\n		if (!file.getParentFile().exists())\r\n		{\r\n			file.getParentFile().mkdirs();\r\n			System.out.println(\"文件夹\"+file.getParentFile()+\"原来不存在，已经新建好了！\");\r\n		}\r\n\r\n		try\r\n		{\r\n			file.createNewFile();\r\n//			System.out.println(filePath+\"原来不存在，已经创建成功！\");\r\n		} catch (IOException e)\r\n		{\r\n			e.printStackTrace();\r\n			System.out.println(filePath+\"创建文件失败唉\");\r\n		}\r\n		try\r\n		{\r\n//			FileOutputStream out = new FileOutputStream(file);\r\n			BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\r\n				    new FileOutputStream(file), encoding));\r\n//			byte buy[] = tcContent.getBytes();// 以字节流的方式写入到文件中\r\n//			out.write(buy);\r\n			out.write(content);\r\n			out.close();\r\n//			System.out.println(\"-----------------\"+filePath+\"----------写入成功！\");\r\n		} catch (FileNotFoundException e)\r\n		{\r\n			System.out.println(filePath+\"写入文件内容失败！文件未找到的错误如下：\");\r\n			e.printStackTrace();\r\n		} catch (IOException e)\r\n		{\r\n			System.out.println(filePath+\"写入文件内容失败！流错误如下：\");\r\n			e.printStackTrace();\r\n		}\r\n\r\n	}\r\n	/*************************************************************\r\n	* @Title      : exists\r\n	* @Description: 判断文件是够存在\r\n	* @param      : @param filePath\r\n	* @param      : @return\r\n	* @return     ：  boolean 返回类型 :存在的话就返回true\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 上午11:46:04\r\n	*************************************************************/\r\n	public static boolean exists(String filePath)\r\n	{\r\n		boolean exists = false;\r\n		File file = new File(filePath);\r\n		if(file.exists())\r\n		{\r\n			exists = true;\r\n		}\r\n		return exists;\r\n	}\r\n/*************************************************************\r\n	* @Title      : delete\r\n	* @Description: 删除指定文件/文件夹\r\n	* @param      : @param filePath\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 下午11:14:38\r\n	*************************************************************/\r\n	public static void delete(String filePath)\r\n	{\r\n		File file = new File(filePath);\r\n		if(file.exists())\r\n		{\r\n//			System.out.println(\"文件存在的！！\");\r\n			file.delete();\r\n		}\r\n	}\r\n	/*************************************************************\r\n	* @Title      : changeCharset\r\n	* @Description: 将字符串的集合进行转化\r\n	* @param      : @param str\r\n	* @param      : @param fromCharset\r\n	* @param      : @param toCharset\r\n	* @param      : @return\r\n	* @param      : @throws Throwable\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016年12月23日 上午9:21:18\r\n	*************************************************************/\r\n	public static String changeCharset(String str,String fromCharset,String toCharset) throws Throwable\r\n	{\r\n		return new String(str.getBytes(\"GBK\"), \"UTF-8\");\r\n	}\r\n	/*************************************************************\r\n	* @Title      : getBaseName\r\n	* @Description: TODO(这里用一句话描述这个方法的作用)\r\n	* @param      : @param filePath\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型 :返回取出的文件名\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年1月14日 下午10:47:43\r\n	*************************************************************/\r\n	public static String getBaseName(String filePath)\r\n	{\r\n		return filePath.substring(filePath.lastIndexOf(\"\\\\\")+1, filePath.lastIndexOf(\".\"));\r\n	}\r\n	/*************************************************************\r\n	* @Title      : getRelativePath\r\n	* @Description: 根据文件路径和根路径得到相对路径\r\n	* @param      : @param filePath\r\n	* @param      : @param rootPath\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年1月14日 下午10:50:38\r\n	*************************************************************/\r\n	public static String getRelativePath(String filePath,String rootPath)\r\n	{\r\n		return filePath.replace(rootPath, \"\");//直接把路径的无用部分剔除掉\r\n	}\r\n\r\n	//删除文件夹\r\n	//param folderPath 文件夹完整绝对路径\r\n\r\n    /*************************************************************\r\n	* @Title      : delFolder\r\n	* @Description: 删除指定文件夹\r\n	* @param      : @param folderPath\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年2月14日 上午8:34:04\r\n	*************************************************************/\r\npublic static void delFolder(String folderPath)\r\n	  {\r\n	     try\r\n	     {\r\n	        delAllFile(folderPath); //删除完里面所有内容\r\n	        String filePath = folderPath;\r\n	        filePath = filePath.toString();\r\n	        File myFilePath = new File(filePath);\r\n	        myFilePath.delete(); //删除空文件夹\r\n	     } catch (Exception e)\r\n	     {\r\n	       e.printStackTrace();\r\n	     }\r\n	  }\r\n\r\n	//删除指定文件夹下所有文件\r\n	//param path 文件夹完整绝对路径\r\n	   public static boolean delAllFile(String path) {\r\n	       boolean flag = false;\r\n	       File file = new File(path);\r\n	       if (!file.exists()) {\r\n	         return flag;\r\n	       }\r\n	       if (!file.isDirectory()) {\r\n	         return flag;\r\n	       }\r\n	       String[] tempList = file.list();\r\n	       File temp = null;\r\n	       for (int i = 0; i < tempList.length; i++) {\r\n	          if (path.endsWith(File.separator)) {\r\n	             temp = new File(path + tempList[i]);\r\n	          } else {\r\n	              temp = new File(path + File.separator + tempList[i]);\r\n	          }\r\n	          if (temp.isFile()) {\r\n	             temp.delete();\r\n	          }\r\n	          if (temp.isDirectory()) {\r\n	             delAllFile(path + \"/\" + tempList[i]);//先删除文件夹里面的文件\r\n	             delFolder(path + \"/\" + tempList[i]);//再删除空文件夹\r\n	             flag = true;\r\n	          }\r\n	       }\r\n	       return flag;\r\n	     }\r\n\r\n	   /*************************************************************\r\n		* @Title      : deleteFolder\r\n		* @Description: 删除文件夹\r\n		* @param      : @param folderPath\r\n		* @return     ：  void 返回类型\r\n		* @author     : l00379880 梁山广\r\n		* @date       : 2017年2月15日 下午3:49:57\r\n		*************************************************************/\r\n		public static void deleteFolder(String folderPath)\r\n	    {\r\n			Delete fileDetele = new Delete();\r\n			fileDetele.deleteFolder(\"D:\\\\MyProjects\\\\MyEclipse\\\\ScriptAutoGen\\\\results\\\\eSAP\\\\V200R002C30\\\\IKE\");\r\n	    }\r\n\r\n\r\n	/*************************************************************\r\n	* @Title      : reNameSuffix\r\n	* @Description: 对特定文件重命名,只修改后缀即可\r\n	* @param      : @param srcPath:原来的文件路径\r\n	* @param      : @param dstSuffix：要修改成的文件后缀,后缀为空就是去掉后缀\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年3月9日 上午9:24:25\r\n	*************************************************************/\r\n	public static void reNameSuffix(String srcPath, String dstSuffix)\r\n	{\r\n		File file = new File(srcPath); // 指定文件名及路径\r\n		String filename = srcPath.substring(0, srcPath.lastIndexOf(\".\"));\r\n		if(dstSuffix.equals(\"\")||dstSuffix==null)\r\n		{\r\n			file.renameTo(new File(filename)); // 如果后缀为空表名要去掉后缀\r\n		}\r\n		file.renameTo(new File(filename + \".\" + dstSuffix)); // 改名\r\n	}\r\n```', '2017-12-30 19:57:57', '我自己的通用Java文件读写类,实现了文件读取到list、递归读取文件夹下所有文件完整路径到list、递归删除文件夹下所有文件、判断文件是否存在等,并完美解决了中文乱码问题', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514645125617&di=49770ef2a7b8ffe15154ab5f380c9d0c&imgtype=0&src=http%3A%2F%2Fpic.58pic.com%2F58pic%2F15%2F56%2F91%2F33d58PICYGr_1024.png', '原创', b'1', b'1', b'1', 'Java通用文件操作类', '2017-12-30 20:24:54', '37', '1', '1', b'1'), ('19', b'1', b'1', '```java\r\npackage com.huawei.l00379880.mylib.file;\r\n\r\nimport java.io.File;\r\n\r\n/***********************************************************\r\n* @ClassName   : Delete\r\n* @Description : 文件/文件夹的删除类\r\n* @author      : l00379880 梁山广\r\n* @date        : 2017年2月15日 下午3:42:04\r\n***********************************************************/\r\npublic class Delete\r\n{\r\n	private static String matches = \"[A-Za-z]:\\\\\\\\[^:?\\\"><*]*\";\r\n	boolean flag = false;\r\n	File file;\r\n	public boolean deleteFolder(String deletePath) {// 根据路径删除指定的目录或文件，无论存在与否\r\n		flag = false;\r\n		if (deletePath.matches(matches)) {\r\n			file = new File(deletePath);\r\n			if (!file.exists()) {// 判断目录或文件是否存在\r\n				return flag; // 不存在返回 false\r\n			} else {\r\n\r\n				if (file.isFile()) {// 判断是否为文件\r\n					return deleteFile(deletePath);// 为文件时调用删除文件方法\r\n				} else {\r\n					return deleteDirectory(deletePath);// 为目录时调用删除目录方法\r\n				}\r\n			}\r\n		} else {\r\n			System.out.println(\"要传入正确路径！\");\r\n			return false;\r\n		}\r\n	}\r\n	public boolean deleteFile(String filePath) {// 删除单个文件\r\n		flag = false;\r\n		file = new File(filePath);\r\n		if (file.isFile() && file.exists()) {// 路径为文件且不为空则进行删除\r\n			file.delete();// 文件删除\r\n			flag = true;\r\n		}\r\n		return flag;\r\n	}\r\n\r\n	public boolean deleteDirectory(String dirPath) {// 删除目录（文件夹）以及目录下的文件\r\n		// 如果sPath不以文件分隔符结尾，自动添加文件分隔符\r\n		if (!dirPath.endsWith(File.separator)) {\r\n			dirPath = dirPath + File.separator;\r\n		}\r\n		File dirFile = new File(dirPath);\r\n		// 如果dir对应的文件不存在，或者不是一个目录，则退出\r\n		if (!dirFile.exists() || !dirFile.isDirectory()) {\r\n			return false;\r\n		}\r\n		flag = true;\r\n		File[] files = dirFile.listFiles();// 获得传入路径下的所有文件\r\n		for (int i = 0; i < files.length; i++) {// 循环遍历删除文件夹下的所有文件(包括子目录)\r\n			if (files[i].isFile()) {// 删除子文件\r\n				flag = deleteFile(files[i].getAbsolutePath());\r\n//				System.out.println(files[i].getAbsolutePath() + \" 删除成功\");\r\n				if (!flag) {\r\n                    break;// 如果删除失败，则跳出\r\n                }\r\n			} else {// 运用递归，删除子目录\r\n				flag = deleteDirectory(files[i].getAbsolutePath());\r\n				if (!flag) {\r\n                    break;// 如果删除失败，则跳出\r\n                }\r\n			}\r\n		}\r\n//		System.out.println(dirPath+\"删除成功！\");\r\n		if (!flag) {\r\n            return false;\r\n        }\r\n		if (dirFile.delete()) {// 删除当前目录\r\n			return true;\r\n		} else {\r\n			return false;\r\n		}\r\n	}\r\n}\r\n\r\n```', '2017-12-30 20:37:54', '自己实现的递归删除文件夹下所有文件的类', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514648045569&di=e0ffda888e0b77c9e3551e5e0b1e3d31&imgtype=0&src=http%3A%2F%2Fpic.58pic.com%2F58pic%2F15%2F87%2F47%2F39a58PICycS_1024.jpg', '原创', b'1', b'1', b'1', 'Java删除文件夹', '2017-12-31 00:36:48', '50', '1', '1', b'0'), ('21', b'1', b'1', '转眼之间，已经毕业一年多了，这一年，经历了太多太多。\r\n### 恰同学少年\r\n15年9月，貌似我的校招特别顺利，华为给我开了特殊起薪还专门请我们SP吃饭，永远忘不了刚面试完华为一小时，导员激动地给我说华为校招的老大拍板说会给我会加很多特殊起薪，让我千万别签别的公司。加上面试的人简直让我相见恨晚，自此边认定了华为，校招也几乎还没开始就结束了。\r\n### 直面现实\r\n16年6月底,拿到毕业证的第三天就只身一人拽着一箱书来到了千里之外的南京.<br>\r\n从出生到大学毕业,除了一次坐公交睡着坐过站到了河北外,还从没出过省.<br>\r\n听说南京房价在我来前半年的时间,从两万涨到了四万.<br>\r\n听说华为会随机分配,比如答应我去做算法,最后分到了测试.<br>\r\n听说我司经常会加班,比如半夜过点.<br>\r\n听说工作后人会变得很圆滑,最终会变成自己讨厌的样子.<br>\r\n听说.....<br>\r\n当所有的听说变成赤裸裸的现实,突然觉得曾经的努力在现实面前,是那么苍白.<br>\r\n还未配好剑,转身已是江湖.\r\n### 那些忙碌而快乐的日子\r\n入职后,得知转岗的难度后,问了HR一句,<br>\r\n\"测试部有写代码的部门吗?\"<br>\r\n\"自动化主要写代码,不过比较杂,什么语言都用\".<br>\r\n\"那我就去自动化\"<br>\r\n后来在在自动化一年先后用过Java、Ruby、Python、C#、VBA...<br>\r\n曾经和主管晓华哥、师傅天名哥还有柯东哥,经常一起happy地吃完18块的自助后回来欢实地加班到11点...<br>\r\n巅峰时期一周四顿自助,后来自助被我们吃倒闭了...<br>\r\n后来在胖了整整胖了20斤的那天,拿到了优秀新员工<br>\r\n后来晓华哥去了阿里,柯东哥去了华三,烦闷的某天,来到我师父那,开玩笑似地问了一句<br>\r\n\"师傅,你是不是也要走?\"<br>\r\n\"嘘!你咋知道\"师傅一脸震惊+懵逼<br>\r\n\"我不知道啊\"<br>\r\n然后师傅去了网易.<br>\r\n.......................................................................<br>\r\n无比怀念四个人胡吃海喝的日子.<br>\r\n原来以为学校中的离别是最让人伤心的.现在才发现职场的离别更残酷.<br>\r\n起码学校的离别是可期的,但在职场中,你要做好随时目送身边朋友们离开的准备<br>\r\n### 因为\"真话\"而改变的命运\r\n不曾想到一个花了两分钟写地帖子会让公司震动两个月,也不曾想到一句略带戏谑的呼喊会演变成一场全公司范围内的整风运动.<br>\r\n两个月,无日不在战战兢兢、如履薄冰.<br>\r\n然后是平静生活中的一声惊雷,<br>\r\n这辈子都没敢奢望过会有交集的任总亲自发文支持我<br>\r\n然后是连升两级、加薪、配股.<br>\r\n开心吗?<br>\r\n不开心是假的,但开心维持了不超过一天.<br>\r\n先是头条,然后是网易、UC、百度、微博热搜,第二天开始到了东方卫视、江西电视台、深圳电视台、无数的自媒体、北京青年报、人民日报........<br>\r\n事情的发酵程度远远超出了我的想象,从心声\"达人\"变成了社会\"网红\"<br>\r\n终于知道舆论的可怕,它们黑白不分、颠倒是非,为了博人眼球群起而诋毁之<br>\r\n一个被符号化的人是很难存在于现实中的.<br>\r\n很多在我说真话时的怂恿者,变成了升两级之后的诋毁者.<br>\r\n人言可畏,人心可恨.<br>\r\n很多人会期望你替他们出头,却见不得你因此而得到好的结果<br>\r\n于是乎,原来漫山遍野的支持者、欢呼者、怂恿者,变成了质疑者、嫉妒者、嘲弄者.<br>\r\n终于知道孔令贤前辈为何逃离华为.<br>\r\n只因单薄的肩膀承担不起充满劣根性的小人的诽谤.<br>\r\n单纯的技术人在华为是很难生存下去的,因为越是想突出的人,越会被无数双挑剔的眼睛盯着.<br>\r\n### 后\"网红\"的日子\r\n过去三个月,经历了太多太多,心态也逐渐平和,终于能静下心来好好看看书、写写代码.<br>\r\n心声也被我重定向到localhost了.<br>\r\n告别那些戾气满满的日子,未来好好加油!<br>\r\n----------------------------------------------2017-11-05 14:26 于华为上海研究所-----------------------------------------------\r\n', '2017-12-31 00:11:35', '我们要鼓励员工及各级干部讲真话，真话有正确的、不正确的，各级组织采纳不采纳，并没什么问题，而是风气要改变', 'https://img.huxiucdn.com/article/cover/201709/08/084247486452.png', '原创', b'1', b'1', b'1', '我来华为的一年', '2017-12-31 00:37:03', '144', '11', '1', b'1'), ('25', b'1', b'1', '## 概念阐述\r\n### 完全二叉树\r\n>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\r\n   \r\n### 堆有序\r\n>当一颗完全二叉树的每个节点都大于(或小于)等于他的两个子节点时,被称为堆有序\r\n   \r\n### 二叉堆\r\n>一组能够用堆有序的完全二叉树排序的元素\r\n\r\n### 最大堆\r\n>每个节点都大于等于他的两个子节点的二叉堆\r\n\r\n### 最小堆\r\n>每个节点都小于等于他的两个子节点的二叉堆\r\n', '2018-01-03 17:52:08', '学习优先队列和堆排序的过程中,老是和算法中的二叉查找树混淆,因此专门来总结下容易混淆的概念。并结合代码进行详细分析和讲解', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514983044736&di=1488d67e60740e5aa1d61aaefe8b99e1&imgtype=0&src=http%3A%2F%2Fimages.cnitblog.com%2Fi%2F606550%2F201403%2F051251148735812.jpg', '原创', b'1', b'1', b'1', '优先队列与堆排序解析', '2018-01-03 21:52:42', '67', '2', '1', b'1'), ('28', b'1', b'1', '> 利用IDEA编辑器的Live Templates可以实现自定义方法、属性、注释等，下面是我自己的常用模板。\r\n\r\n\r\n## 属性模板\r\n### pri : private int 类型属性声明\r\n```java\r\nprivate int $END$;\r\n```\r\n### prs : private String 类型属性声明\r\n```java\r\nprivate String $END$;\r\n```\r\n## 函数模板\r\n### pub : public boolean 方法声明\r\n```java\r\npublic boolean $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pui : public int 方法声明\r\n```java\r\npublic int $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pus : public String 方法声明\r\n```java\r\npublic String $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pusb : public static boolean 方法声明\r\n```java\r\npublic static boolean $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pusi : public static  int 静态方法声明\r\n```java\r\npublic static int $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### puss : public static String 方法声明\r\n```java\r\npublic static String $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n## 注释模板\r\n### multicomment ：多行注释\r\n```java\r\n/**\r\n * 描述: $END$\r\n * 日期: $DATE$ $TIME$ \r\n * 作者: 梁山广\r\n */\r\n ```\r\n ### singlecomment : 单行注释\r\n ```java\r\n // $END$ by 梁山广 at $DATE$ $TIME$ \r\n ```\r\n \r\n ## 自动生成时间戳的设置($DATE$ 和 $TIME$)\r\n ![自动生成时间戳的设置][1]\r\n\r\n\r\n  [1]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-IDEA%E5%BF%AB%E9%80%9F%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90--1515222173160.jpg', '2018-01-05 21:48:47', '利用IDEA编辑器自带的Live Templates可以极大地提高编程效率,比如快速完成属性、方法、注释、插入时间戳,Postfix可以快速完成常见的for循环、异常捕获、非空判断等等.在此把自己的经验总结下', 'http://img.blog.csdn.net/20161013150532137', '原创', b'1', b'1', b'1', ' IDEA 下Java快速代码生成', '2018-01-06 16:53:24', '97', '1', '1', b'1'), ('29', b'1', b'1', '## 类头注释\r\n+ 打开file->setting->Editor->Filr and Code Templates->Includes->File Header ,直接在右边的文件框里编辑你说需要注释的东西，然后应用保存之后,当你创建类的时候就会自动生成注释。\r\n![类注释](http://img.blog.csdn.net/20161013144235558)\r\n\r\n## 方法注释\r\n+ 打开file->setting->Editor->LiveTemplates点击右边上面那个绿色的+号，选择Template Group双击，然后弹出一个窗口，随便添加一个名字，我这里添加的是MyGroup然后点击OK\r\n![方法注释](http://img.blog.csdn.net/20161013145113147 \"方法注释\")\r\n+ 还是在file->setting->Editor->LiveTemplates这个路径下点击一下刚刚你添加的那个名字（我这是MyGroup），然后点击右边上面那个绿色的+号，选择LiveTemplate双击，填写下面的图上的框 \r\n![](http://img.blog.csdn.net/20161013145852869)\r\n+ 然后点击\r\n![](http://img.blog.csdn.net/20161013150017182)\r\n+ 然后选择Everywhere\r\n![](http://img.blog.csdn.net/20161013150219245)\r\n+ 最后点击右下角的Edit variables 按钮，然后弹出一个窗口，如下： \r\n![](http://img.blog.csdn.net/20161013150532137)\r\n+ 如果想把 @param：每一个参数可以这样 \r\n![](http://img.blog.csdn.net/20161202130929702)\r\n+ 参数值要自己写的\r\n```groovy\r\n groovyScript(\"def result=\'\'; def params=\\\"${_1}\\\".replaceAll(\'[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]\', \'\').split(\',\').toList(); for(i = 0; i < params.size(); i++) {result+=\' * @param \' + params[i] + ((i < params.size() - 1) ? \'\\\\n\\\\b\' : \'\')}; return result\", methodParameters())\r\n```\r\n+ 把这个添加进去，但是还要注意一点： \r\n![](http://img.blog.csdn.net/20161202131406143)\r\n+ 下面红色圈中的下拉框选择相对应的参数点击OK \r\n再点击apply,点击Ok。 \r\n然后写方法之前点写上add（刚刚填的）按tab，注释就出来了。\r\n\r\n', '2018-01-05 22:13:23', 'Intellij IDEA中利用Live Templates生成类注释和方法注释,教程很实用.关键是能生成时间戳', 'http://img.blog.csdn.net/20161013150532137', '转载', b'1', b'1', b'1', ' IntelliJ设置类头注释和方法注释(含时间戳)', '2018-01-06 00:31:40', '52', '1', '1', b'0'), ('30', b'1', b'1', '---\r\ntitle: 2018-1-6-个人博客、博客园、微信公众号、Github、本地同步写博客\r\ntags: Markdown,教程,同步\r\n\r\n---\r\n\r\n> 全篇教程是利用Markdown神器--小书匠进行串联地，墙裂推荐大家使用\r\n\r\n[Toc]\r\n\r\n### 1.写博客\r\n下载[小书匠][1]，关于Markdown的语法此处不再介绍。\r\n点击新建，创建自己的第一篇博客。\r\n\r\n![小书匠Markdown编辑器][2]\r\n\r\n\r\n![小书匠介绍][3]\r\n### 2.发布到博客园\r\n> 前提:自己去博客园主页注册下\r\n\r\n点击左上角的“小书匠”三个字，进入配置区，配置好自己的博客园地址、用户名、密码，然后点击发布即可。然后去自己的博客园主页就能看到发布的文章了\r\n\r\n\r\n![发布博客到博客园][4]\r\n  \r\n  ### 3.发布到自己的博客\r\n  > 把Mardown文件内容复制过去就行了\r\n  \r\n  ![发布到自己的博客][5]\r\n  \r\n  见我的博客:[我的博客地址][6]\r\n  \r\n  ### 4.同步到Github\r\n  点击左上角的“小书匠”三个字，进入配置区,点击绑定，按照里面的教程配置好数据存储和图床，各为自己Github上的Repo即可\r\n \r\n![enter description here][7]\r\n  \r\n  配置好后，在小书匠中添加图片时会自动加入到图床Repo中到Github中并取回URL，\r\n  \r\n  写完博客，点击另存为，选择前面配置好的Github上的Repo下的目录\r\n  \r\n  博客md文件会自动存到另一个博客的Repo中\r\n  \r\n### 5.博客发布到自己的微信公众号中\r\n微信公众号的排版问题一直很受人诟病，虽然有Mardown Here一类的插件，但是仍然很麻烦，这里一个很简单的方法是直接去博客园的后台博客管理页面，把前面发布的博客内容直接拷贝到微信公众号的编辑界面里，所有样式都能完整保存！！！\r\n\r\n![博客园样式完整复制到微信公众号][8]\r\n\r\n![enter description here][9]\r\n\r\n\r\n  [1]: http://soft.xiaoshujiang.com/download.html\r\n  [2]: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515240811611&di=c953882348f1bd2ff840c9a25593423f&imgtype=0&src=http://down.52pk.com/uploads/170710/5000_164015_1_lit.jpg\r\n  [3]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1728-%E5%B0%8F%E4%B9%A6%E5%8C%A0.png \"2018-01-06_1728-小书匠\"\r\n  [4]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1733-%E5%B0%8F%E4%B9%A6%E5%8C%A0%E5%8F%91%E5%B8%83%E5%88%B0%E5%8D%9A%E5%AE%A2%E5%9B%AD.png \"2018-01-06_1733-小书匠发布到博客园\"\r\n  [5]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1752-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.png \"2018-01-06_1752-自己的博客\"\r\n  [6]: http://liangshanguang.wang/\r\n  [7]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1757-%E5%B0%8F%E4%B9%A6%E5%8C%A0%E5%88%A9%E7%94%A8Github%E5%BD%93%E5%9B%BE%E5%BA%8A%E5%92%8C%E5%8D%9A%E5%AE%A2%E5%AD%98%E5%82%A8.png \"2018-01-06_1757-小书匠利用Github当图床和博客存储\"\r\n  [8]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1825--%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%B8%AD.png \"2018-01-06_1825--博客园复制到微信公众号中\"\r\n  [9]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1827--%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%A0%B7%E5%BC%8F%E5%AE%8C%E7%BE%8E%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png \"2018-01-06_1827--博客园样式完美复制到微信公众号\"', '2018-01-06 18:42:55', '常用的写博客方式博客园、微信公众号、个人博客很难统一，而且免费图床几乎没有，自己好好研究下了，找了个给予Github托管的写博客方式。', 'http://img.25pp.com/uploadfile/app/icon/20160707/1467861288876739.jpg', '原创', b'1', b'1', b'1', '全渠道同步写博客的技巧', '2018-01-06 18:44:05', '90', '17', '1', b'0'), ('31', b'1', b'1', '> 在人间有谁活着不是一场炼狱\r\n\r\n今天，离我16年7月7日入职整整过去一年半了，猛地发现自己正处于人生中最尴尬的时期，\r\n不再享有新员工的犯错权，也步入了催房催婚催孩子的时期，\r\n职场遇到发展的瓶颈和迷茫，越来越多人的亲人朋友依托和寄希望于你，\r\n周围的浮躁和喧嚣让你想不清自己到底想要什么，看到同龄人买房、买车、结婚、晋升总会陷入痛苦的比较与自卑，\r\n周围人讨论的永远都是房子、车子、孩子、股票、分红、八卦……\r\n越来越体会到这个社会的阶级壁垒远比你想象地要厚且令人绝望。\r\n在人间有谁活着不是一场炼狱，然而仍然要不断抗争下去，你好，2018\r\n', '2018-01-07 14:17:22', '毕业很久了，感慨颇多', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515315894127&di=46572f57447b0b9326a173999b6cfbc5&imgtype=0&src=http%3A%2F%2Fupload.71.cn%2F2016%2F0728%2F1469675540696.jpg', '原创', b'1', b'1', b'1', '毕业一年半', '2018-01-12 00:10:04', '85', '11', '1', b'1'), ('32', b'1', b'1', '> int *pi=&a; printf(\"%d\\n\",*pi); 打印的是a的值，而不是&a\r\n\r\n###  先看下面一段代码\r\n```c\r\nint a=50;\r\nint b=60;\r\nint *pi=&a;\r\nprintf(\"%d\\n\",*pi);\r\npi=&b;\r\nprintf(\"%d\\n\",*pi);\r\nprintf(\"%d\\n\",pi);\r\n```\r\n### 结果是：\r\n\r\n```bash\r\n50\r\n60\r\n2686708\r\n```\r\n### 常有的疑惑\r\n* **第7行和第9行的赋值方式看起来不一样，为啥都能取到值？>第7行和第9行的赋值方式看起来不一样，为啥都能取到值？ 第8行的*pi不该是&a值吗？**\r\n### 解惑\r\n + `java int *pi=&a`其实等效于```(int *)pi=&a```,含义是：给int指针类型的变量pi赋值为a的地址。\r\n + `pi=&b`含义：给int指针类型的变量pi重新赋值为b的地址。可见和上面的含义是完全一致地\r\n + 之所以会有上面的疑惑，是因为误把`(int *)pi`和`*pi`中的`*`看成一个含义了。其实两者是完全不同地：前者是声明pi的类型为指针类型；后者时取pi中的地址指针指向的元素的值。pi本身存储的是a的地址，所以控制台输出的是a的地址值即2686708\r\n', '2018-01-10 14:40:15', '(int *)pi 和 *pi 千万别混啊.....', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515576301772&di=e58be9ad53b755955d37f4ba672a457e&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D1962452276%2C4074126980%26fm%3D214%26gp%3D0.jpg', '原创', b'1', b'1', b'1', '指针变量初始化赋值与使用的区别', '2018-01-11 22:39:47', '118', '4', '1', b'1'), ('34', b'1', b'1', ' >我辈生，生有所信；我辈死，死得其所。不苟活而生，唯信念而死！\r\n \r\n 知章骑马似乘船，眼花落井水底眠。\r\n\r\n 汝阳三斗始朝天，道逢麴车口流涎，恨不移封向酒泉。\r\n\r\n 左相日兴费万钱，饮如长鲸吸百川，衔杯乐圣称避贤。\r\n\r\n 宗之潇洒美少年，举觞白眼望青天，皎如玉树临风前。\r\n\r\n 苏晋长斋绣佛前，醉中往往爱逃禅。\r\n\r\n 李白斗酒诗百篇，长安市上酒家眠，天子呼来不上船，自称臣是酒中仙。\r\n\r\n 张旭三杯草圣传，脱帽露顶王公前，挥毫落纸如云烟。\r\n\r\n 焦遂五斗方卓然，高谈雄辩惊四筵。\r\n\r\n\r\n\r\n', '2018-01-12 00:19:18', '我辈生，生有所信；我辈死，死得其所。不苟活而生，唯信念而死！', 'https://i.loli.net/2018/01/12/5a5796722f148.png', '原创', b'1', b'1', b'1', '《饮中八仙歌》', '2018-01-12 00:59:40', '58', '18', '1', b'1'), ('35', b'1', b'1', '>人们常常怀念那些过去的事，不是因为它有多美好，而是它再也回不来了\r\n\r\n莺啼啼不尽，任燕语、语难通。这一点间愁，十年不断，恼乱春风。重来故人不见，但依然、杨柳小楼东。记得同题粉壁，而今壁破无踪。 \r\n\r\n兰皋新涨绿溶溶。流恨落花红。念着破春衫，当时送别，灯下裁缝。相思谩然自苦，算云烟、过眼总成空。落日楚天无际，凭栏目送飞鸿。\r\n\r\n', '2018-01-12 00:39:02', '人们常常怀念那些过去的事，不是因为它有多美好，而是它再也回不来了', 'http://5b0988e595225.cdn.sohucs.com/images/20170730/89e95840a8fd4f68820e842ec4900f07.jpeg', '原创', b'1', b'1', b'1', '《木兰花慢·莺啼啼不尽》', '2018-01-12 20:57:00', '66', '18', '1', b'1'), ('36', b'1', b'1', '+ i-当前光标前面插入字符 a-当前光标后面插入字符\r\n\r\n+ esc-返回命令模式 :wq-保存退出\r\n\r\n+ shift+a-跳到末尾插入字符 shift+i-行首\r\n\r\n+ o-当前行下面开一行插入字符 shift+o-上一行\r\n\r\n+ 光标一到某个位置按x删除\r\n\r\n+ 命令模式下按两次d删除整行', '2018-01-12 11:05:31', 'vim下的常用指令', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515736373838&di=bec4302b533b3ba9704002e6a18d948f&imgtype=jpg&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D2076193515%2C624247639%26fm%3D214%26gp%3D0.jpg', '原创', b'1', b'1', b'1', 'Vim常用指令', '2018-01-12 11:05:31', '59', '8', '1', b'1'), ('37', b'1', b'1', '```c++\r\n /*************************************************************************************\r\n     *****c++类的实现应该是在\".h\"文件中声明后在.cpp文件中用“返回值 类名::函数名...”来实现**\r\n     ************************************************************************************/\r\n\r\n    int myStringExtension::getInt(std::string str) {\r\n        int num = 0;\r\n        std::stringstream os;\r\n        os << str;\r\n        os >> num;\r\n        return num;\r\n    }\r\n\r\n    std::string myStringExtension::getString(int num) {\r\n        std::string str;\r\n        std::stringstream os;\r\n        os << num;\r\n        os >> str;\r\n        return str;\r\n    }\r\n\r\n    std::string myStringExtension::getTrim(std::string str) {\r\n        str.erase(0, str.find_first_not_of(\" \"));\r\n        str.erase(str.find_last_not_of(\" \") + 1);\r\n        return str;\r\n    }\r\n```', '2018-01-12 20:40:22', '目前有字符串转整型、整型转字符串、trim', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2774751207,3568559995&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', '基于STL封装自己的字符串操作类', '2018-01-12 20:41:55', '34', '4', '1', b'1'), ('38', b'0', b'1', '> 在这个不美好的世上，最美好的童话总是悲伤地，她们都是用饱受自我牺牲的崇高和孤独所折磨的灵魂写成地，满溢着无边的悲寂感，透明而凄美，原原本本地展现出生命本身的重量\r\n\r\n> 我们在属于自己的那座城里筑梦，不求闻达于世，但终究还是希望可以留下点什么，或许仅仅是为了被某个人偶然地想起\r\n\r\n>凡心所向，素履所往，生如逆旅，一苇以航。<br>\r\n稣合于言，安之若素。自言自语，无喜无悲。<br>\r\n凡心所向，素履所往，生如逆旅，一苇以航。<br>\r\n三月桃花，四月欢唱，两人一马，明日故乡。<br>\r\n流浪陌路，暖然绯凉，写意人生，相识一场。<br>\r\n不关此世，不负己心，我自倾杯，且君随意。\r\n\r\n> 不安于心，不困于情。不畏将来，不念过往。如此，安好。', '2018-01-12 20:55:23', '在这个不美好的世上，最美好的童话总是悲伤地', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516367209&di=64857504a35daf94eaebdc443933c1f8&imgtype=jpg&er=1&src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201609%2F03%2F20160903233848_BzyxF.thumb.700_0.jpeg', '原创', b'1', b'1', b'1', '美好的童话总是悲伤地', '2018-01-12 21:46:13', '84', '17', '1', b'1'), ('39', b'0', b'1', '参考自知乎：[在 Mac OS X 中怎样获取当前文件夹的路径？](https://www.zhihu.com/question/22883229/answer/22956721)\r\n\r\n## 快捷键\r\n使用 `command+option+c`即可把当前文件（夹）的路径复制到粘贴板中\r\n## 更好：在Finder最上面显示当前文件件路径\r\n+ 打开终端，输入下面的命令：\r\n```bash \r\ndefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\r\n```\r\n+ 就能在顶部看见完整的地址了\r\n![在Finder最上面看到地址](https://pic4.zhimg.com/50/031824973905702098e296e7352eb679_hd.jpg)\r\n+ 在Finder顶端的地址栏右键，还可以直接访问路径中的任意一层\r\n![还可以右键跳到任何一层](https://pic1.zhimg.com/50/64e6693cb7cae3bca2d0e41379d8c5fa_hd.jpg)\r\n\r\n\r\n', '2018-01-14 13:25:39', 'mac访问、复制当前路径', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516512282&di=c51e03a2b9d09a132c7453dc3db34db2&imgtype=jpg&er=1&src=http%3A%2F%2Fimages.apple.com%2Fv%2Fmac%2Fhome%2Fq%2Fhome%2Fimages%2Faccessories_mac_large_2x.jpg', '转载', b'1', b'1', b'0', 'Mac中获取当前文件夹的路径', '2018-01-14 13:27:04', '69', '19', '1', b'0'), ('40', b'1', b'1', '## 创建线程的时候传入`单个`参数\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n\r\n/**\r\n * 线程的处理函数，都声明称指针函数的形式\r\n *\r\n * @param arg 万能参数，可以使任何数据类型 这里是个整型\r\n */\r\nvoid *pth_func(void *arg) {\r\n    int n = (int) arg;\r\n    for (int i = 0; i < n; i++) {\r\n        printf(\"id of pthread :%ld,i=%d\\n\", pthread_self(), i);\r\n        // 进行随机延迟\r\n        // 随机函数：随机产生0.0到1.0的一个随机数\r\n        double r = drand48();\r\n        // 方法一下\r\n        int rt = (int) (r * 100000);\r\n        // 睡眠rt微妙(usleep中u的来源)\r\n        usleep(rt);\r\n    }\r\n}\r\n\r\nint main() {\r\n    pthread_t pth1;\r\n    pthread_t pth2;\r\n    // 错误编号\r\n    int err;\r\n    // 错误码非0表示线程创建失败\r\n    if ((err = pthread_create(&pth1, NULL, pth_func, (void *) 100)) != 0) {\r\n        fprintf(stderr, \"pthread create fail:%s\\n\", strerror(err));\r\n        exit(1);\r\n    }\r\n    if ((err = pthread_create(&pth2, NULL, pth_func, (void *) 100)) != 0) {\r\n        fprintf(stderr, \"pthread create fail:%s\\n\", strerror(err));\r\n        exit(1);\r\n    }\r\n    // 主控线程不能先于两个子线程结束，所以要延时一下，确保主线程最后结束\r\n    sleep(10);\r\n    printf(\"finish!\\n\");\r\n    return 0;\r\n}\r\n```\r\n## 创建线程的时候传入`多个`参数(结构体)\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n\r\ntypedef struct pth_arg {\r\n    int start;\r\n    int end;\r\n} pth_arg;\r\n\r\n/**\r\n * 传参改为结构体\r\n */\r\nvoid *pth_func(void *arg) {\r\n	// 这里的数据类型强转也和上面不一样\r\n    pth_arg *pa = (pth_arg *) arg;\r\n    for (int i = pa->start; i < pa->end; i++) {\r\n        printf(\"id of pthread :%ld,i=%d\\n\", pthread_self(), i);\r\n        // 进行随机延迟\r\n        // 随机函数：随机产生0.0到1.0的一个随机数\r\n        double r = drand48();\r\n        // 方法一下\r\n        int rt = (int) (r * 100000);\r\n        // 睡眠rt微妙(usleep中u的来源)\r\n        usleep(rt);\r\n    }\r\n}\r\n\r\nint main() {\r\n    pthread_t pth1;\r\n    pthread_t pth2;\r\n    // 错误编号\r\n    int err;\r\n    // 传多个参数\r\n    pth_arg arg1 = {1, 100};\r\n    // 错误码非0表示线程创建失败\r\n    if ((err = pthread_create(&pth1, NULL, pth_func, (void *) &arg1)) != 0) {\r\n        fprintf(stderr, \"pthread create fail:%s\\n\", strerror(err));\r\n        exit(1);\r\n    }\r\n    pth_arg arg2 = {50, 80};\r\n    if ((err = pthread_create(&pth2, NULL, pth_func, (void *) &arg2)) != 0) {\r\n        fprintf(stderr, \"pthread create fail:%s\\n\", strerror(err));\r\n        exit(1);\r\n    }\r\n    sleep(10);\r\n    printf(\"finish!\\n\");\r\n    return 0;\r\n}\r\n```', '2018-01-16 20:34:55', 'pthread创建线程，给了多个参数形式(整型和结构体)', 'http://www.grabsun.com/uploads/images/2012/38/il27_1.jpg', '原创', b'1', b'1', b'1', 'Linux C多线程：创建线程', '2018-01-16 20:55:18', '39', '4', '1', b'1'), ('41', b'1', b'1', '## 1.线程`执行完毕`退出\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n\r\ntypedef struct pth_arg {\r\n    int start;\r\n    int end;\r\n} pth_arg;\r\n\r\n/**\r\n * 线程函数\r\n */\r\nvoid *pth_func(void *arg) {\r\n    pth_arg *pa = (pth_arg *) arg;\r\n    int sum = 0;\r\n    for (int i = pa->start; i < pa->end; i++) {\r\n        sum += i;\r\n    }\r\n    // 退出方式1：线程执行完毕退出\r\n    return (void *) sum;\r\n}\r\n\r\nint main() {\r\n    pthread_t pth1;\r\n    pthread_t pth2;\r\n    // 错误编号\r\n    int err;\r\n    // 传多个参数\r\n    pth_arg arg1 = {1, 100};\r\n    // 错误码非0表示线程创建失败\r\n    if ((err = pthread_create(&pth1, NULL, pth_func, (void *) &arg1)) != 0) {\r\n        fprintf(stderr, \"pthread create fail:%s\\n\", strerror(err));\r\n        exit(1);\r\n    }\r\n    int *ret;\r\n    // 以阻塞式的方式等待线程结束\r\n    pthread_join(pth1, (void **) &ret);\r\n    printf(\"sum:%d\\n\", (int) ret);\r\n    printf(\"finish!\\n\");\r\n    return 0;\r\n}\r\n```\r\n## 2.调用`pthread_exit()主动退出`\r\npthread_exit()函数后面的命令不会再执行了\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n\r\ntypedef struct pth_arg {\r\n    int start;\r\n    int end;\r\n} pth_arg;\r\n\r\n/**\r\n * 线程函数\r\n */\r\nvoid *pth_func(void *arg) {\r\n    pth_arg *pa = (pth_arg *) arg;\r\n    int sum = 0;\r\n    for (int i = pa->start; i < pa->end; i++) {\r\n        sum += i;\r\n    }\r\n    // 退出方式2：调用pthread_exit退出，主动退出，后面的命令不会再执行了\r\n    pthread_exit((void *) sum);\r\n    printf(\"应该打印不出这句话了！^_^\");\r\n}\r\n\r\nint main() {\r\n    pthread_t pth1;\r\n    pthread_t pth2;\r\n    // 错误编号\r\n    int err;\r\n    // 传多个参数\r\n    pth_arg arg1 = {1, 100};\r\n    // 错误码非0表示线程创建失败\r\n    if ((err = pthread_create(&pth1, NULL, pth_func, (void *) &arg1)) != 0) {\r\n        fprintf(stderr, \"pthread create fail:%s\\n\", strerror(err));\r\n        exit(1);\r\n    }\r\n    int *ret;\r\n    // 以阻塞式的方式等待线程结束\r\n    pthread_join(pth1, (void **) &ret);\r\n    printf(\"sum:%d\\n\", (int) ret);\r\n    printf(\"finish!\\n\");\r\n    return 0;\r\n}\r\n```\r\n## 3.被`另一个线程`调用`kill函数`所取消\r\n基本不用，因为很容易造成`死锁`', '2018-01-17 10:36:24', 'pthread多线程退出的三种方式：执行完毕退出、调用pthread_exit主动退出、被另一个线程调用kill函数所取消', 'http://www.2cto.com/uploadfile/2013/0124/20130124111643577.jpg', '原创', b'1', b'1', b'1', 'Linux C多线程：线程退出的多种方式', '2018-01-17 10:44:23', '44', '4', '1', b'1'), ('42', b'1', b'1', '```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n#include <memory.h>\r\n#include <unistd.h>\r\nvoid out_attr(pthread_attr_t attr) {\r\n    int stat;\r\n    int errCode = pthread_attr_getdetachstate(&attr, &stat);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n    } else {\r\n        if (stat == PTHREAD_CREATE_JOINABLE) {\r\n            printf(\"正常属性:PTHREAD_CREATE_JOINABLE\\n\");\r\n        } else if (stat == PTHREAD_CREATE_DETACHED) {\r\n            printf(\"分类属性:PTHREAD_CREATE_DETACHED\\n\");\r\n        } else {\r\n            printf(\"属性设置错误\");\r\n        }\r\n    }\r\n}\r\nvoid *thread_func(void *arg) {\r\n    int sum = 0;\r\n    for (int i = 0; i < 100; i++) {\r\n        sum += i;\r\n    }\r\n    return (void *) sum;\r\n}\r\nint main(void) {\r\n    pthread_t pth1;\r\n    pthread_t pth2;\r\n    // 线程属性\r\n    pthread_attr_t attr;\r\n    // 为属性结构分配内存空间，并通过参数 attr返回分配的内存空间的首地址\r\n    pthread_attr_init(&attr);\r\n    out_attr(attr);\r\n    // 这里的attr用地默认地，不管分离不分离\r\n    int errCode = pthread_create(&pth1, &attr, thread_func, (void *) 0);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    int ret;\r\n    errCode = (pthread_join(pth1, (void *) &ret));\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n        exit(1);\r\n    } else {\r\n        printf(\"ret中的数据之和：%d\\n\", ret);\r\n    }\r\n    printf(\"---------------------------下面是分离属性的线程---------------------------------\\n\");\r\n    // 设置分离状态.(改变上面设置的attr,然后用这个attr来初始化pth2)\r\n    errCode = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    errCode = pthread_create(&pth2, &attr, thread_func, (void *) 0);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n	// 分离后导致pthread_join函数出错，所以主线程不能依靠该函数等待线程执行完毕，而必须使用sleep()函数休眠等待线程执行完毕\r\n    sleep(1);\r\n    // 设置了分离属性后，按理说线程结束状态应该不关心了，所以应该获取不到退出码。thread_join函数无法调用,输出Invalid argumentn\r\n    errCode = pthread_join(pth2, (void *) 0);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n        exit(1);\r\n    } else {\r\n        printf(\"ret中的数据之和：%d\\n\", ret);\r\n    }\r\n    // 进行属性内存空间的释放\r\n    errCode = pthread_attr_destroy(&attr);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%sn\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n', '2018-01-17 15:49:46', '线程在设置分离属性后可以避免僵尸进程，但同时也没法调用pthread_join函数了，因为分离属性是把结束状态分离出去了', 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2396980970,1511030948&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C多线程：线程的分离状态', '2018-01-17 16:14:25', '48', '4', '1', b'1'), ('43', b'1', b'1', '## 头文件(account.h)\r\n```c\r\n#ifndef JIKEXUEYUAN_ACCOUNT_H\r\n#define JIKEXUEYUAN_ACCOUNT_H\r\ntypedef struct Account {\r\n    double balance;  // 金额\r\n    char id[20];     // 用户id\r\n    char pwd[20];    // 用户密码\r\n    pthread_mutex_t mutex;\r\n} Account;\r\n/**\r\n * 账户初始化\r\n * @param id        用户id\r\n * @param password  用户密码\r\n * @return          生成的用户结构体\r\n */\r\nAccount *account_init(char *id, char *password, double balance);\r\n/**\r\n * 销户\r\n * @param account 账户结构体\r\n */\r\nvoid account_destroy(Account *account);\r\n/**\r\n * 取钱\r\n * @param account  账户对象\r\n * @param amt      取钱金额\r\n * @return         账户余额\r\n */\r\ndouble account_withdraw(Account *account, double amt);\r\n/**\r\n * 存钱\r\n * @param account  账户对象\r\n * @param amt      要存的金额\r\n * @return         账户余额\r\n */\r\ndouble account_deposit(Account *account, double amt);\r\n/**\r\n * 查询账户余额\r\n * @param account  账户对象\r\n * @return         账户余额\r\n */\r\ndouble account_query(Account *account);\r\n#endif //JIKEXUEYUAN_ACCOUNT_H\r\n```\r\n## 头文件实现(account.c)\r\n```c\r\n#include <stddef.h>\r\n#include <malloc.h>\r\n#include <assert.h>\r\n#include <memory.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"account.h\"\r\nAccount *account_init(char *id, char *password, double balance) {\r\n    Account *account = calloc(1, sizeof(Account));\r\n    assert(account != NULL);\r\n    // 设置各个属性,字符拷贝智能用strcpy.整型可以直接赋值\r\n    strcpy(account->id, id);\r\n    strcpy(account->pwd, password);\r\n    account->balance = balance;\r\n    // 这里的初始化一定要做！！要不锁就无效了！\r\n    pthread_mutex_init(&account->mutex,NULL);\r\n    return account;\r\n}\r\nvoid account_destroy(Account *account) {\r\n    assert(account != NULL);\r\n    pthread_mutex_destroy(&account->mutex);\r\n    free(account);\r\n    account = NULL;\r\n}\r\ndouble account_withdraw(Account *account, double amt) {\r\n    assert(account != NULL);\r\n    pthread_mutex_lock(&account->mutex);\r\n    double balance = account_query(account);\r\n    usleep(100);\r\n\r\n    if (amt > balance || amt < 0) {\r\n        // 如果取款大于余额或者取款金额小于0\r\n        printf(\"操作异常！\");\r\n        // 操作异常就释放锁\r\n        pthread_mutex_unlock(&account->mutex);\r\n        exit(1);\r\n    }\r\n    // 余额减去取的前\r\n    balance -= amt;\r\n    account->balance = balance;\r\n    // 取完款，释放锁\r\n    pthread_mutex_unlock(&account->mutex);\r\n    return amt;\r\n}\r\ndouble account_deposit(Account *account, double amt) {\r\n    assert(account != NULL);\r\n    double balance = account->balance;\r\n    usleep(100);\r\n    if (amt < 0) {\r\n        printf(\"操作异常\");\r\n        exit(1);\r\n    }\r\n    balance += amt;\r\n    account->balance = balance;\r\n    return amt;\r\n}\r\ndouble account_query(Account *account) {\r\n    assert(account != NULL);\r\n    double balance = account->balance;\r\n    usleep(10000);\r\n    return balance;\r\n}\r\n```', '2018-01-17 19:28:42', 'pthread互斥锁案例', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516781575&di=0a163c91025875034df375075c473769&imgtype=jpg&er=1&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fpic%2Fitem%2F824bb07eca8065380e27c7cb97dda144af3482f4.jpg', '原创', b'1', b'1', b'1', 'Linux C多线程：互斥锁', '2018-01-17 19:28:42', '32', '4', '1', b'1'), ('44', b'1', b'1', '## 主测试文件\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include <memory.h>\r\n#include <pthread.h>\r\n#include \"my_mutex/account.h\"\r\n\r\ntypedef struct User {\r\n    char name[20];\r\n    Account *account;\r\n} User;\r\n\r\nvoid *thread_func_withdraw(void *arg) {\r\n    User *u = (User *) arg;\r\n    double amt = account_withdraw(u->account, 10000);\r\n    // 打印取钱信息\r\n    printf(\"name: %s,withdraw:%lf,thread id:%lx\\n\", u->name, amt, pthread_self());\r\n    // 不关心退出多少，所以退出0就行\r\n    return (void *) 0;\r\n}\r\n\r\nint main(void) {\r\n    // 初始化账户\r\n    Account *account = account_init(\"6225\", \"123\", 10000);\r\n    User *husband = calloc(1, sizeof(User));\r\n    assert(husband != NULL);\r\n    strcpy(husband->name, \"Danny\");\r\n    husband->account = account;\r\n    // 老婆和老公共享一个账户属性\r\n    User *wife = calloc(1, sizeof(User));\r\n    assert(wife != NULL);\r\n    strcpy(wife->name, \"Lily\");\r\n    wife->account = account;\r\n\r\n    // 下面创建两个线程进行同时取钱操作\r\n    pthread_t pth_husband;\r\n    pthread_t pth_wife;\r\n    int errCode = pthread_create(&pth_husband, NULL, thread_func_withdraw, (void *) husband);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%s\\n\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    errCode = pthread_create(&pth_wife, NULL, thread_func_withdraw, (void *) wife);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%s\\n\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    // 等待被控线程退出\r\n    pthread_join(pth_husband, NULL);\r\n    pthread_join(pth_wife, NULL);\r\n    // 一定记得销户\r\n    account_destroy(account);\r\n    return 0;\r\n}\r\n```\r\n\r\n讲linux多线程的好文章:[http://www.grabsun.com/article/2012/870963.html](http://www.grabsun.com/article/2012/870963.html)\r\n', '2018-01-17 19:37:30', '对上一篇银行账户的多线程互斥锁的例子进行测试', 'http://www.grabsun.com/uploads/images/2012/38/il27_1.jpg', '原创', b'1', b'1', b'1', 'Linux C多线程：互斥锁', '2018-01-17 19:37:30', '42', '4', '1', b'1'), ('45', b'1', b'1', '> 理论基础见博客：[http://blog.csdn.net/encoder1234/article/details/52183763](http://blog.csdn.net/encoder1234/article/details/52183763)\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n#include <string.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n    if (argc < 2) {\r\n        fprintf(stderr, \"usage: %s lock_type\\n\",\r\n                argv[0]);\r\n        exit(1);\r\n    }\r\n    pthread_mutexattr_t attr;\r\n    pthread_mutexattr_init(&attr);\r\n    // 系统默认的是锁是：PTHREAD_MUTEX_DEFAULT\r\n    if (!strcmp(argv[1], \"normal\")) {\r\n        // 标准互斥锁(锁中加锁容易造成死锁，即第一次上锁成功，后面卡死)\r\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);\r\n    } else if (!strcmp(argv[1], \"recursive\")) {\r\n        // 递归互斥锁(不会造成死锁，多次上锁都会成功地，会记录递归层数)\r\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\r\n    } else if (!strcmp(argv[1], \"error\")) {\r\n        // 检错互斥锁(外面层次上了锁，里面的再上锁就会失败，但不会造成死锁)\r\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);\r\n    } else {\r\n        printf(\"unkown type!\\n\");\r\n        exit(1);\r\n    }\r\n    //pthread_mutexattr_init(&attr);\r\n    pthread_mutex_t mutex;\r\n    pthread_mutex_init(&mutex, &attr);\r\n    // 下面上了两次锁\r\n    if (pthread_mutex_lock(&mutex) != 0) {\r\n        printf(\"first lock failed!\\n\");\r\n    } else {\r\n        printf(\"first lock success!\\n\");\r\n    }\r\n\r\n    if (pthread_mutex_lock(&mutex) != 0) {\r\n        printf(\"second lock failed!\\n\");\r\n    } else {\r\n        printf(\"second lock success!\\n\");\r\n    }\r\n    pthread_mutexattr_destroy(&attr);\r\n    pthread_mutex_destroy(&mutex);\r\n    return 0;\r\n}\r\n\r\n```', '2018-01-17 20:09:43', 'pthread_mutexattr_gettype函数可以获得互斥锁类型属性。合法的类型属性值有：PTHREAD_MUTEX_NORMAL；PTHREAD_MUTEX_ERRORCHECK；PTHREAD_MUTEX_RECURSIVE；PTHREAD_MUTEX_DEFAULT。本文结合代码讨论其区别', 'http://img.blog.csdn.net/20130717162318140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3R0aHVuYWdjaG5lZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center', '原创', b'1', b'1', b'1', 'Linux C多线程：互斥锁的类型', '2018-01-17 20:21:53', '40', '4', '1', b'1'), ('46', b'1', b'1', '## 参考博客\r\n+ [linux网络编程之posix条件变量](http://www.cnblogs.com/webor2006/p/4254865.html)\r\n+ [Linux多线程编程详细解析----条件变量 pthread_cond_t](https://www.cnblogs.com/jiu0821/p/6424951.html)\r\n+ [linux线程同步(2)-条件变量](https://www.cnblogs.com/yuuyuu/p/5140875.html)\r\n+ [Linux多线程编程详细解析----条件变量 pthread_cond_t](http://blog.csdn.net/ithomer/article/details/6031723)\r\n+ [Linux C语言多线程库Pthread中条件变量的的正确用法逐步详解](http://blog.csdn.net/kxcfzyk/article/details/29240953)\r\n+ [非常精简的Linux线程池实现:使用互斥锁和条件变量](http://blog.csdn.net/kxcfzyk/article/details/31719687)\r\n', '2018-01-18 10:15:38', '条件变量的基本概念以及代码示例', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516781575&di=0a163c91025875034df375075c473769&imgtype=jpg&er=1&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fpic%2Fitem%2F824bb07eca8065380e27c7cb97dda144af3482f4.jpg', '原创', b'1', b'1', b'1', 'Linux C多线程：条件变量学习博客', '2018-01-18 11:52:57', '37', '4', '1', b'1'), ('47', b'1', b'1', '## 头文件 `result.h`\r\n```c\r\n#ifndef JIKEXUEYUAN_RESULT_H\r\n#define JIKEXUEYUAN_RESULT_H\r\n\r\n#include <pthread.h>\r\n\r\ntypedef struct Result {\r\n    int sum;                // 求和结果\r\n    pthread_cond_t cond;    // 条件变量\r\n    pthread_mutex_t mutex;  // 互斥锁\r\n    int isWait;             // 是否工作\r\n} Result;\r\nResult *result_init();\r\nvoid result_destroy(Result *result);\r\nvoid result_set(Result *result, int value);\r\nint result_get(Result *result);\r\n#endif //JIKEXUEYUAN_RESULT_H\r\n```\r\n## 实现 `result.c`\r\n```c\r\n#include \"result.h\"\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include <unistd.h>\r\nResult *result_init() {\r\n    Result *result = (Result *) calloc(1, sizeof(Result));\r\n    assert(result != NULL);\r\n    // 条件变量初始化\r\n    pthread_cond_init(&result->cond, NULL);\r\n    // 互斥锁初始化\r\n    pthread_mutex_init(&result->mutex, NULL);\r\n    // 让让另一个线程知道自己什么时候开始工作了\r\n    result->isWait = 0;\r\n    return result;\r\n}\r\nvoid result_destroy(Result *result) {\r\n    assert(result!= NULL);\r\n    // 释放条件变量\r\n    pthread_cond_destroy(&result->cond);\r\n    // 释放互斥锁\r\n    pthread_mutex_destroy(&result->mutex);\r\n    free(result);\r\n}\r\nvoid result_set(Result *result, int value) {\r\n    assert(result != NULL);\r\n    // 加锁\r\n    pthread_mutex_lock(&result->mutex);\r\n    // 是0的话就一直循环下去\r\n    while (result->isWait == 0) {\r\n        // 又套了一层是为了消除时间差，保证一有广播就立马去获取值\r\n        pthread_mutex_unlock(&result->mutex);\r\n        usleep(100);\r\n        pthread_mutex_lock(&result->mutex);\r\n    }\r\n    pthread_mutex_unlock(&result->mutex);\r\n    result->sum = value;\r\n    // 广播出去,get函数中获取通知结果\r\n    pthread_cond_broadcast(&result->cond);\r\n}\r\nint result_get(Result *result) {\r\n    assert(result != NULL);\r\n    pthread_mutex_lock(&result->mutex);\r\n    result->isWait = 1;\r\n    // 阻塞以接收广播数据\r\n    pthread_cond_wait(&result->cond, &result->mutex);\r\n    // 解锁\r\n    pthread_mutex_unlock(&result->mutex);\r\n    return result->sum;\r\n}\r\n```\r\n## 测试文件 `main.c`\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <memory.h>\r\n#include \"my_thread_condition/result.h\"\r\n\r\nvoid *calculate_func(void *arg) {\r\n    Result *r = (Result *) arg;\r\n    int i = 0;\r\n    int s = 0;\r\n    for (i; i <= 100; i++) {\r\n        s += i;\r\n    }\r\n    result_set(r, s);\r\n    return (void *) 0;\r\n}\r\nvoid *print_func(void *arg) {\r\n    Result *r = (Result *) arg;\r\n    int s = result_get(r);\r\n    printf(\"sum:%d\\n\", s);\r\n    return (void *) 0;\r\n}\r\nint main(void) {\r\n    pthread_t print_thread;\r\n    pthread_t calculate_thread;\r\n    Result *result = result_init();\r\n    int errCode;\r\n    errCode = pthread_create(&calculate_thread, NULL, calculate_func, (void *) result);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%s\\n\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    errCode = pthread_create(&print_thread, NULL, print_func, (void *) result);\r\n    if (errCode != 0) {\r\n        fprintf(stderr, \"%s\\n\", strerror(errCode));\r\n        exit(1);\r\n    }\r\n    pthread_join(print_thread, NULL);\r\n    pthread_join(calculate_thread, NULL);\r\n    result_destroy(calculate_thread);\r\n    return 0;\r\n}\r\n```', '2018-01-18 11:44:08', '条件变量的demo', 'https://images0.cnblogs.com/blog/324374/201501/280815008786405.png', '原创', b'1', b'1', b'1', 'Linux C多线程：条件变量实现求和', '2018-01-18 11:51:52', '43', '4', '1', b'1'), ('48', b'1', b'1', '## 例子\r\n+ 当一个线程互斥地访问某个变量时，它可能发现在其它线程改变状态之前，它什么也做不了。如下图：\r\n  + (1)不加互斥锁和条件变量时存在的问题\r\n ![不加互斥锁和条件变量时存在的问题](https://images0.cnblogs.com/blog/324374/201501/280801231289111.png)\r\n  + (2)加互斥锁但是不加条件变量时存在的问题\r\n   ![加互斥锁但是不加条件变量时存在的问题](https://images0.cnblogs.com/blog/324374/201501/280809306751060.png)\r\n  + (3)加上互斥锁和条件变量后成功解决问题\r\n  ![加上互斥锁和条件变量后成功解决问题](https://images0.cnblogs.com/blog/324374/201501/280815008786405.png)\r\n  \r\n>这实际上可以解决生产者与消费者问题，而且对于缓冲区是无界的是一种比较理解的解决方案，只有有产品时才通知消费者开始消费产品，生产者不关心缓存区是否满\r\n\r\n## 条件变量函数详解\r\n![](https://images0.cnblogs.com/blog/324374/201501/282242302227372.png)\r\n\r\n**参考博文**：[linux网络编程之posix条件变量](http://www.cnblogs.com/webor2006/p/4254865.html)', '2018-01-18 12:03:04', '条件变量的详述，结合例子来讲', 'https://images0.cnblogs.com/blog/324374/201501/282242302227372.png', '转载', b'1', b'1', b'1', 'Linux C多线程：条件变量详例解析', '2018-01-18 14:14:29', '51', '4', '1', b'1'), ('49', b'1', b'1', '## 测试代码\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <memory.h>\r\n#include <unistd.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n    if (argc < 3) {\r\n        fprintf(stderr, \"usage: %s file return | exit | _exit\\n\", argv[0]);\r\n        exit(1);\r\n    }\r\n\r\n    // 下面进行判断是哪种退出方式\r\n    FILE *fp = fopen(argv[1], \"w\");\r\n    char *str = \"hello world\";\r\n    fprintf(fp, \"%s\", str);\r\n    if (!strcmp(argv[2], \"return\")) {\r\n        // 执行完毕退出\r\n        return 0;\r\n    } else if (!strcmp(argv[2], \"exit\")) {\r\n        // 调用atexit()函数退出\r\n        exit(0);\r\n    } else if (!strcmp(argv[2], \"_exit\")) {\r\n        // 直接退出\r\n        _exit(0);\r\n    } else {\r\n        // 程序出错了，打印消息\r\n        printf(\"程序出错啦！\");\r\n    }\r\n    return 0;\r\n}\r\n```\r\n## 输出分析\r\n>输出如下，可见return和exit函数退出前都会刷新缓冲区，所以会把“Hello World”写入txt文件，_exit函数时直接退出，不刷新缓冲区，所以c.txt中啥都没有\r\n\r\n```bash\r\nroot@me:~# ./a.out ./a.txt return\r\nroot@me:~# ls\r\na.out  a.txt  Makefile  thread_create.c  进程退出.c\r\nroot@me:~# ./a.out ./b.txt exit\r\nroot@me:~# ./a.out ./c.txt _exit\r\nroot@me:~# more *.txt\r\n::::::::::::::\r\na.txt\r\n::::::::::::::\r\nhello world\r\n::::::::::::::\r\nb.txt\r\n::::::::::::::\r\nhello world\r\n::::::::::::::\r\nc.txt\r\n::::::::::::::\r\n```\r\n**参考文章:**[exit()和_exit()函数](https://www.cnblogs.com/hnrainll/archive/2011/08/17/2142001.html)', '2018-01-18 15:12:33', '进程退出的三种方式：return、exit、_exit的举例解析', 'https://images.cnblogs.com/cnblogs_com/feisky/11.jpg', '原创', b'1', b'1', b'1', 'Linux C进程：进程退出的三种方式', '2018-01-18 15:33:36', '42', '4', '1', b'1');
INSERT INTO `t_blog` VALUES ('50', b'1', b'1', '```c\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n#include <stdlib.h>\r\n\r\nint main(void) {\r\n    // 保存进程id.是个整型书\r\n    pid_t pid;\r\n    pid = fork();\r\n    if (pid < 0) {\r\n        fprintf(stderr, \"fork error: %s\\n\", strerror(errno));\r\n        exit(1);\r\n    } else if (pid == 0) {\r\n        // 说明是子进程\r\n        printf(\"this is a chile, it\'s id is : %u,it\'s parent id is %u\\n\", getpid(), getppid());\r\n    } else {\r\n        printf(\"this is parent, it\'s id is : %u, child\'s pid is : %u\\n\", getpid(), pid);\r\n    }\r\n    return 0;\r\n}\r\n```', '2018-01-18 18:23:11', 'Linux C进程创建，获取父进程与子进程的id', 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4076891408,1603973694&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C进程：进程创建与id', '2018-01-18 18:23:22', '37', '4', '1', b'1'), ('51', b'1', b'1', '## Semantic-ui\r\n> 不说啥，就是喜欢，我觉得最漂亮的前端框架。自己的博客就是基于这个做的\r\n\r\n + [官网](https://semantic-ui.com/)   \r\n + [Github](https://github.com/Semantic-Org/Semantic-UI)   \r\n + [网易云课堂教程](http://study.163.com/course/introduction/1002886003.htm)  \r\n + [我的博客](http://120.79.75.27/)\r\n \r\n## Foundation\r\n> 也很漂亮，不过我还没用过，马上学习\r\n\r\n+ [官网](http://foundation.zurb.com/)\r\n+ [Github](https://github.com/zurb/foundation-sites)\r\n+ [慕课网教程1](https://www.imooc.com/learn/835)\r\n+ [慕课网教程2](https://www.imooc.com/learn/838)\r\n\r\n## Materialize\r\n> 一个基于 Material Design 的 CSS 框架。\r\n\r\n+ [官网](http://materializecss.com)\r\n+ [Github](https://github.com/Dogfalo/materialize)\r\n\r\n## Material-ui\r\n> 集成 Google Material 设计的 React 组件。\r\n\r\n+ [官网](http://www.material-ui.com/)\r\n+ [Github](https://github.com/callemall/material-ui)\r\n\r\n## Phantomjs\r\n可以用于 页面自动化 ， 网络监测 ， 网页截屏 ，以及 无界面测试 等。\r\n\r\n+ [官网](http://phantomjs.org/)\r\n+ [Github](https://github.com/ariya/phantomjs)\r\n\r\n## Pure\r\n\r\n+ [官网](https://purecss.io/)\r\n+ [GitHub](https://github.com/yahoo/pure)\r\n+ [中文教程](https://www.purecss.cn/)\r\n\r\n## Flat-ui\r\nFlat UI是基于Bootstrap做的Metro化改造，由Designmodo提供。Flat UI包含了很多Bootstrap提供的组件，但是外观更加漂亮。Flat UI Flat UI是一套精美的扁平风格 UI 工具包，基于 Twitter Bootstrap 实现。\r\n\r\n+ [官网](http://designmodo.com/flat-free/)\r\n+ [Github](https://github.com/designmodo/Flat-UI)\r\n\r\n## React-bootstrap\r\n\r\n+ [官网](https://react-bootstrap.github.io/)\r\n+ [Github](https://github.com/react-bootstrap/react-bootstrap)\r\n\r\n## Uikit\r\n\r\n+ [官网](https://getuikit.com/)\r\n+ [GitHub](https://github.com/uikit/uikit)\r\n+ [中文教程](http://www.getuikit.net)\r\n\r\n## Metro-ui-css\r\n> Win8风格，巨硬粉必备\r\n\r\n+ [官网](http://metroui.org.ua/)\r\n+ [Github](https://github.com/olton/Metro-UI-CSS)\r\n\r\n## Mui\r\n> MUI 是一个轻量级的CSS框架，遵循Google的Material Design设计方针。\r\n\r\n+ [官网](https://www.muicss.com/)\r\n+ [Github](https://github.com/muicss/mui)\r\n\r\n## Frozenui\r\n> 腾讯的移动端UI框架\r\n\r\n+ [官网](http://frozenui.github.io)\r\n+ [Github](https://github.com/frozenui/frozenui)\r\n\r\n## AlloyUI\r\n+ [官网](http://alloyui.com/)\r\n+ [Github](https://github.com/liferay/alloy-ui)\r\n\r\n', '2018-01-18 19:53:17', '比较常用Bootstrap和Layui，还有些UI也不错，在此推荐下。semantic和foundation要好好学下了', 'http://www.primeton.com/uploads/image/20160930/20160930121759_85999.jpg', '原创', b'1', b'1', b'1', '几个自己非常喜欢的前端框架', '2018-01-19 09:04:08', '112', '20', '1', b'1'), ('52', b'1', b'1', '## 常见信号表\r\n在终端，可通过kill -l查看所有的signal信号\r\n[![常用信号种类.png](https://i.loli.net/2018/01/18/5a60b2442fbab.png)](https://i.loli.net/2018/01/18/5a60b2442fbab.png)\r\n对于signal信号，绝大部分的默认处理都是终止进程或停止进程，或dump内核映像转储。 上述的31的信号为非实时信号，其他的信号32-64 都是实时信号。\r\n\r\n## 例子\r\n> 下面的例子实现了重写SIGINT(即Ctrl+C事件)，Ctrl+C后打印出进程信息。然后继续运行\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <signal.h>\r\n#include <memory.h>\r\n#include <errno.h>\r\n// linux下是unistd.h。Mac下是zconf.h\r\n#include <zconf.h>\r\n\r\nvoid sig_handler(int signo){\r\n    printf(\"pid:%d, signal num: %d---------------------信号发生了！\",getpid(),signo);\r\n}\r\n\r\nint main(void) {\r\n    printf(\"hello world\");\r\n    if(signal(SIGINT,sig_handler)==SIG_ERR){\r\n        //出错了\r\n        fprintf(stderr,\"signal error : %s\\n\",strerror(errno));\r\n    }\r\n    int i=0;\r\n    while (1){\r\n        printf(\"i:%d\\n\",i++);\r\n        sleep(1);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 结果如下图\r\n[![覆写Ctrl+C事件.png](https://i.loli.net/2018/01/18/5a60c296dbef9.png)](https://i.loli.net/2018/01/18/5a60c296dbef9.png)\r\n \r\n## 子进程继承了父进程的消息处理方式\r\n```c\r\n#include <stdio.h>\r\n#include <signal.h>\r\n#include <memory.h>\r\n#include <errno.h>\r\n#include <zconf.h>\r\n#include <stdlib.h>\r\n\r\nvoid sig_handler(int signo) {\r\n    printf(\"pid:%d, signal num: %d---------------------信号发生了！\", getpid(), signo);\r\n}\r\n\r\nvoid out(int n) {\r\n    for (int i = 0; i < n; ++i) {\r\n        sleep(1);\r\n        printf(\"pid: %d,i:%d\\n\", getpid(), i);\r\n    }\r\n}\r\n\r\nint main(void) {\r\n    if (signal(SIGTSTP, sig_handler) == SIG_ERR) {\r\n        //出错了\r\n        fprintf(stderr, \"signal error : %s\\n\", strerror(errno));\r\n    }\r\n    pid_t pid;\r\n    pid = fork();\r\n    if (pid < 0) {\r\n        fprintf(stderr, \"fork error: %s\\n\", strerror(errno));\r\n        exit(1);\r\n    } else if (pid > 0) {\r\n        // 父进程\r\n        out(100);\r\n    } else {\r\n        // 子进程\r\n        out(100);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 结果如下\r\n[![子进程继承了父进程的信号处理方式.png](https://i.loli.net/2018/01/19/5a60c6f5a2862.png)](https://i.loli.net/2018/01/19/5a60c6f5a2862.png)\r\n', '2018-01-18 20:35:27', 'Linux C中常见信号及其含义，并写了一个例子进行说明。注意Mac下getpid()是在zconf.h中，但linux下是在unistd.h中', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516289287974&di=4d990f4cfb32b60341bea943166b9707&imgtype=0&src=http%3A%2F%2Fstatic.oschina.net%2Fuploads%2Fspace%2F2014%2F1021%2F163732_6SAM_1756851.png', '原创', b'1', b'1', b'1', 'Linux C信号：常见信号及覆写Ctrl+C事件', '2018-01-19 09:31:36', '62', '4', '1', b'1'), ('53', b'1', b'1', '## 连续发送多次信号时\r\n\r\n### 发送同一个信号多次\r\n> 信号只处理前两次，后面的都被忽略，并且第二次发送的信号会等待第一次信号处理完再处理\r\n\r\n### 交替发送不同信号\r\n\r\n> 马上处理新来的信号。内核中对信号的处理是由信号屏蔽字和未决字共同决定地，信号不排队等待。\r\n\r\n## 例子\r\n\r\n### 代码\r\n```c\r\n#include <signal.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n#include <errno.h>\r\n#include <memory.h>\r\n#include <stdlib.h>\r\n\r\n/**\r\n * 信号处理函数\r\n */\r\nint signal_handler(int signo) {\r\n    if (signo == SIGTSTP) {\r\n        printf(\"pid: %d,catch SIGTSTP(Ctrl+Z) signal...\\n\", getpid());\r\n        // 休眠3s是为了有时间获取多个信号.3s内两个信号做多各处理一次\r\n        sleep(3);\r\n        printf(\"SIGTSTP(Ctrl+Z) END\\n\");\r\n    }\r\n    if (signo == SIGINT) {\r\n        printf(\"pid: %d,catch SIGINT(Ctrl+C) signal...\\n\", getpid());\r\n        sleep(3);\r\n        printf(\"SIGINT(Ctrl+C) END\\n\");\r\n    }\r\n}\r\n\r\nint main(void) {\r\n    if (signal(SIGTSTP, signal_handler) == SIG_ERR) {\r\n        fprintf(stderr, \"signal %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n    if (signal(SIGINT, signal_handler) == SIG_ERR) {\r\n        fprintf(stderr, \"signal %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n    // 下面是死循环不断等待信号过来\r\n    while (1) {\r\n        pause();\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 输出\r\n\r\n```Batch\r\n^Zpid: 80941,catch SIGTSTP(Ctrl+Z) signal...\r\n^ZSIGTSTP(Ctrl+Z) END\r\npid: 80941,catch SIGTSTP(Ctrl+Z) signal...\r\nSIGTSTP(Ctrl+Z) END\r\n\r\n\r\n\r\n^Zpid: 80941,catch SIGTSTP(Ctrl+Z) signal...\r\n^Z^Z^Z^ZSIGTSTP(Ctrl+Z) END\r\npid: 80941,catch SIGTSTP(Ctrl+Z) signal...\r\nSIGTSTP(Ctrl+Z) END\r\n\r\n\r\n\r\n^Zpid: 80941,catch SIGTSTP(Ctrl+Z) signal...\r\n^Cpid: 80941,catch SIGINT(Ctrl+C) signal...\r\nSIGINT(Ctrl+C) END\r\nSIGTSTP(Ctrl+Z) END\r\n```', '2018-01-19 10:14:01', '信号在多种触发源下的处理方式', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516337994136&di=f4e906e4a73325088252f8c39d4f4b0d&imgtype=0&src=http%3A%2F%2Fs5.51cto.com%2Fwyfs02%2FM01%2F7F%2FC7%2FwKiom1csIHfBzfQjAAK3JjmEaMI550.png', '原创', b'1', b'1', b'1', 'Linux C信号：相同号多次发送时的处理逻辑', '2018-01-19 10:52:14', '53', '4', '1', b'1'), ('54', b'1', b'1', '> 依赖于信号处理函数的代码，最好放在信号处理函数中，否则会变得不可靠\r\n\r\n### 不可靠的代码，执行不到while后面\r\n```c\r\n/**\r\n * 依赖于信号处理函数的代码，最好放在信号处理函数中，否则会变得不可靠\r\n */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <signal.h>\r\n#include <errno.h>\r\n\r\n// 利用标志位可以使得信号处理完了后不回到中断位置\r\nint flag = 0;\r\n\r\nvoid sig_handler(int signo) {\r\n    printf(\"---------------------------------catch signal---------------------------------\\n\");\r\n    flag = 1;\r\n    printf(\"---------------------------------end signal--------------------------------\\n\");\r\n}\r\n\r\nint main(void) {\r\n    if (signal(SIGTSTP, sig_handler) == SIG_ERR) {\r\n        fprintf(stderr, \"signal %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n\r\n    while (flag == 0) {\r\n        // 认为制造主函数和信号处理函数的时间差，这样while后面的函数就不能立马执行了，即变得不可靠了\r\n        sleep(5);\r\n        pause();\r\n    }\r\n    // 下面这一句并不能执行到\r\n    printf(\"action after signal_handler\");\r\n    return 0;\r\n}\r\n```\r\n### 可靠的代码，while后面的代码放到信号处理函数sig_handler中\r\n```c\r\n/**\r\n * 依赖于信号处理函数的代码，最好放在信号处理函数中，否则会变得不可靠\r\n */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <signal.h>\r\n#include <errno.h>\r\n\r\n// 利用标志位可以使得信号处理完了后不回到中断位置\r\nint flag = 0;\r\n\r\nvoid sig_handler(int signo) {\r\n    printf(\"---------------------------------catch signal---------------------------------\\n\");\r\n    flag = 1;\r\n    printf(\"action after signal_handler\");\r\n    printf(\"---------------------------------end signal--------------------------------\\n\");\r\n}\r\n\r\nint main(void) {\r\n    if (signal(SIGTSTP, sig_handler) == SIG_ERR) {\r\n        fprintf(stderr, \"signal %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n\r\n    while (flag == 0) {\r\n        // 认为制造主函数和信号处理函数的时间差，这样while后面的函数就不能立马执行了，即变得不可靠了\r\n        sleep(5);\r\n        pause();\r\n    }\r\n    // 下面这一句并不能执行到\r\n    // printf(\"action after signal_handler\");\r\n    return 0;\r\n}\r\n```', '2018-01-19 10:54:07', '依赖于信号处理函数的代码，最好放在信号处理函数中，否则会变得不可靠', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516337994136&di=f4e906e4a73325088252f8c39d4f4b0d&imgtype=0&src=http%3A%2F%2Fs5.51cto.com%2Fwyfs02%2FM01%2F7F%2FC7%2FwKiom1csIHfBzfQjAAK3JjmEaMI550.png', '原创', b'1', b'1', b'1', 'Linux C信号：信号标志位与信号处理代码', '2018-01-19 10:55:56', '38', '4', '1', b'1'), ('55', b'1', b'1', '## 慢系统调用，处理完信号后，代码再重新开始\r\n### 慢系统调用包括\r\n+ 可能会永远阻塞的系统调用\r\n+ 从终端设备、管道或网络设备上的文件读取\r\n+ 向上述文件写入\r\n+ 某些设备上的文件打开\r\n+ pause和wait系统调用\r\n+ 一些设备的ioctl调用\r\n+ 一些进程间通信函数\r\n\r\n### 举例(从终端的文件读取)\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <signal.h>\r\n#include <errno.h>\r\nvoid sig_handler(int signo) {\r\n    printf(\"--------------------catch SIGTSTP signal---------------------\\n\");\r\n}\r\nint main(void) {\r\n    if (signal(SIGTSTP, sig_handler) == SIG_ERR) {\r\n        fprintf(stderr, \"signal error:  %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n    int n;\r\n    char buffer[100] = {\'\\0\'};\r\n    // 得到标准输入\r\n    n = (int) read(STDIN_FILENO, buffer, 100);\r\n    // 输出到标准输出\r\n    write(STDOUT_FILENO, buffer, (size_t) n);\r\n    return 0;\r\n}\r\n```\r\n## 全局数据区导致不可重入\r\n> 全局数据区(《Linux C程序设计王者归来》P269 图10-7)的变量如果被信号处理函数处理后可能导致正常流程不可重入。正常流程和中断处理流程会对变量的数值相互覆盖影响\r\n\r\n### 代码\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <signal.h>\r\n#include <errno.h>\r\nint g_a[10];\r\nvoid out(int n) {\r\n    int l_a[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        g_a[i] = n;\r\n        l_a[i] = n;\r\n        sleep(1);\r\n    }\r\n    printf(\"\\n---------------print general data-------------------\\n\");\r\n    for (int j = 0; j < 10; j++) {\r\n        printf(\"%d\\t\", g_a[j]);\r\n    }\r\n    printf(\"\\n---------------print local   data-------------------\\n\");\r\n    for (int j = 0; j < 10; j++) {\r\n        printf(\"%d\\t\", l_a[j]);\r\n    }\r\n}\r\nvoid sig_handler(int signo) {\r\n    printf(\"\\n--------------------catch SIGTSTP signal---------------------\\n\");\r\n    out(66);\r\n    printf(\"\\n--------------------end   SIGTSTP signal---------------------\\n\");\r\n}\r\nint main(void) {\r\n    if (signal(SIGTSTP, sig_handler) == SIG_ERR) {\r\n        fprintf(stderr, \"signal error:  %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n    out(22);\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n### 输出\r\n```Batch\r\nroot@SZV1000343207:~/ ./a.out \r\n^Z\r\n--------------------catch SIGTSTP signal---------------------\r\n---------------print general data-------------------\r\n66	66	66	66	66	66	66	66	66	66	\r\n---------------print local   data-------------------\r\n66	66	66	66	66	66	66	66	66	66	\r\n--------------------end   SIGTSTP signal---------------------\r\n---------------print general data-------------------\r\n66	66	66	22	22	22	22	22	22	22	\r\n---------------print local   data-------------------\r\n22	22	22	22	22	22	22	22	22	22	\r\n```\r\n', '2018-01-19 11:40:05', '进程调用“慢”系统调用时，如果发生了信号，内核会终止系统调用从信号处理函数返回后再回复先前的代码文位置继续执行(接上中断前的状态)', 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3899200050,3557912094&fm=15&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C信号：信号的可重入性', '2018-01-19 16:46:42', '43', '4', '1', b'1'), ('56', b'1', b'1', '## 进程间通信的目的\r\n\r\n+ `数据传输`：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。\r\n+ `共享数据`：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。\r\n+ `通知事件`：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。\r\n+ `资源共享`：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。\r\n+ `进程控制`：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。\r\n\r\n## 进程间通讯的方式\r\n +  ![进程通讯方式分类](http://img.blog.csdn.net/20150603134149614)\r\n \r\n`参考博客`：[进程通讯方式及比较](http://blog.sina.com.cn/s/blog_b4ef897e0102vs0q.html)', '2018-01-19 17:00:22', '进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516362441125&di=298d5edc1d3b2a09657306d9e02aba61&imgtype=jpg&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1073545630%2C984243087%26fm%3D214%26gp%3D0.jpg', '原创', b'1', b'1', b'1', 'Linux C进程：进程间通讯的目的及方式', '2018-01-19 17:21:51', '59', '4', '1', b'1'), ('57', b'1', b'1', '> 匿名管道适合父子进程以及兄弟进程之间的通信。\r\n\r\n## 父子间通信\r\n### 代码\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n#include <errno.h>\r\n\r\nint main(void) {\r\n    int fd[2];\r\n    if (pipe(fd) != 0) {\r\n        fprintf(stderr, \"pipe: %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n    pid_t pid;\r\n    pid = fork();\r\n    // 父进程写数据，子进程读数据\r\n    if (pid < 0) {\r\n        fprintf(stderr, \"fork: %s\\n\", strerror(errno));\r\n        exit(1);\r\n    } else if (pid > 0) {// 为父进程\r\n        // 关闭读通道\r\n        close(fd[0]);\r\n        int sum1 = 10;\r\n        int sum2 = 20;\r\n        // 写入数据\r\n        write(fd[1], &sum1, sizeof(int));\r\n        write(fd[1], &sum2, sizeof(int));\r\n        // 写入完毕，关闭写端\r\n        close(fd[1]);\r\n        // 等待子进程结束\r\n        wait(0);\r\n    } else { // 子进程\r\n        // 关闭写通道\r\n        close(fd[1]);\r\n        int sum1;\r\n        int sum2;\r\n        // 读入数据\r\n        read(fd[0], &sum1, sizeof(int));\r\n        read(fd[0], &sum2, sizeof(int));\r\n        // 读入完毕，关闭读端\r\n        close(fd[0]);\r\n        printf(\"sum1: %d, sum2: %d\\n\", sum1, sum2);\r\n        exit(1);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 输出\r\n```bash\r\nsum1: 10, sum2: 20\r\n```\r\n\r\n## 兄弟间通信\r\n### 代码\r\n```c\r\n#include <unistd.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include <memory.h>\r\n\r\nint main(void) {\r\n    int fd[2];\r\n    pid_t pid;\r\n    // 创建第一个子进程\r\n    if (pipe(fd) < 0) {\r\n        // 创建进程异常\r\n        fprintf(stderr, \"pipe: %s\\n\", strerror(errno));\r\n        exit(1);\r\n    }\r\n    pid = fork();\r\n    // 下面的分支里千万别判断pid>0即父进程的情况，要不第二个进程的代码就不可达了\r\n    if (pid < 0) {\r\n        // 创建进程异常\r\n        fprintf(stderr, \"pipe: %s\\n\", strerror(errno));\r\n        exit(1);\r\n    } else if (pid == 0) {\r\n        // 第一个子进程中,关闭读通道\r\n        close(fd[0]);\r\n        int sum1 = 11;\r\n        int sum2 = 22;\r\n        write(fd[1], &sum1, sizeof(int));\r\n        write(fd[1], &sum2, sizeof(int));\r\n        // 写入完毕，关闭写端\r\n        close(fd[1]);\r\n        // 等待另一个子进程结束\r\n        wait(0);\r\n        exit(0);\r\n    }\r\n\r\n    // 创建第二个子进程\r\n    pid = fork();\r\n    if (pid < 0) {\r\n        // 创建进程异常\r\n        fprintf(stderr, \"fork: %s\\n\", strerror(errno));\r\n        exit(1);\r\n\r\n    } else if (pid > 0) {\r\n        // 父进程不用，关闭读写通道\r\n        close(fd[0]);\r\n        close(fd[1]);\r\n        exit(0);\r\n    } else {\r\n        // 第二个子进程中,关闭写通道\r\n        close(fd[1]);\r\n        int sum1;\r\n        int sum2;\r\n        read(fd[0], &sum1, sizeof(int));\r\n        read(fd[0], &sum2, sizeof(int));\r\n        // 写入完毕，关闭写端\r\n        close(fd[0]);\r\n        printf(\"sum1: %d, sum2: %d\\n\", sum1, sum2);\r\n        // 等待另一个子进程结束\r\n        exit(0);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 输出\r\n```bash\r\nsum1: 11, sum2: 22\r\n```\r\n`如果写一个读端已经关闭的通道时，就会产生SIGPIPE信号`\r\n', '2018-01-20 14:51:05', '进程间通信的管道方式，列举了父子间通信和兄弟间通信的例子', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516441092896&di=458c1f019c9c8c3e0a382f668fa4f1a3&imgtype=0&src=http%3A%2F%2Fwww.th7.cn%2Fd%2Ffile%2Fp%2F2016%2F05%2F21%2F6552bcc5611c4c55620e22afb7aede75.jpg', '原创', b'1', b'1', b'1', 'Linux C进程：进程间通信之匿名管道', '2018-01-20 16:46:44', '52', '4', '1', b'1'), ('58', b'1', b'1', '## 协同进程\r\n![管道操作-协同进程.png](https://i.loli.net/2018/01/20/5a62f0632fb27.png)\r\n## 协同进程实现父子进程间的全双工通信\r\n### 代码\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <memory.h>\r\n#include <errno.h>\r\n\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(void) {\r\n    int fda[2];\r\n    int fdb[2];\r\n    if (pipe(fda) < 0 || pipe(fdb) < 0) {\r\n        print_err(\"pip\");\r\n    }\r\n\r\n    pid_t pid;\r\n    pid = fork();\r\n    if (pid < 0) {\r\n        print_err(\"fork\");\r\n    } else if (pid > 0) { // 父进程\r\n        // 父进程,写数据,关闭读端\r\n        close(fda[0]);\r\n        // 父进程,读数据,关闭写端\r\n        close(fdb[1]);\r\n\r\n        int num1 = 11;\r\n        int num2 = 22;\r\n        write(fda[1], &num1, sizeof(int));\r\n        write(fda[1], &num2, sizeof(int));\r\n\r\n        // 读入子进程处理完毕的数据\r\n        int sum;\r\n        read(fdb[0], &sum, sizeof(int));\r\n        printf(\"子进程处理的结果是：%d\\n\", sum);\r\n        // 写入完毕，关闭写通道\r\n        close(fda[1]);\r\n        // 读取完毕，关闭读通道\r\n        close(fdb[0]);\r\n    } else { // 子进程\r\n        // 子进程,读数据,关闭写端\r\n        close(fda[1]);\r\n        // 子进程,写数据,关闭读端\r\n        close(fdb[0]);\r\n\r\n        int num1;\r\n        int num2;\r\n        read(fda[0], &num1, sizeof(int));\r\n        read(fda[0], &num2, sizeof(int));\r\n        printf(\"num1: %d ,num2: %d\\n\", num1, num2);\r\n        // 把处理完后的数据写入b通道\r\n        int sum = num1 + num2;\r\n        write(fdb[1], &sum, sizeof(int));\r\n        // 读入完毕，关闭读通道\r\n        close(fda[0]);\r\n        // 写入完毕，关闭写通道\r\n        close(fdb[1]);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 输出\r\n```bash\r\nnum1: 11 ,num2: 22\r\n子进程处理的结果是：33\r\n```\r\n\r\n## 协同进程实现兄弟进程间的双工通信\r\n### 代码\r\n```c\r\n#include <unistd.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include <memory.h>\r\n\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(void) {\r\n    int fda[2];\r\n    int fdb[2];\r\n    pid_t pid;\r\n    if (pipe(fda) < 0 || pipe(fdb) < 0) {\r\n        print_err(\"pipe\");\r\n    }\r\n\r\n    pid = fork();\r\n    // 下面的分支里千万别判断pid>0即父进程的情况，要不第二个进程的代码就不可达了\r\n    if (pid < 0) {\r\n        print_err(\"fork\");\r\n    } else if (pid == 0) {\r\n        // 创建第一个子进程，进程1\r\n        // 子进程1,写数据,关闭读端\r\n        close(fda[0]);\r\n        // 子进程1,读数据,关闭写端\r\n        close(fdb[1]);\r\n\r\n        int num1 = 11;\r\n        int num2 = 22;\r\n        write(fda[1], &num1, sizeof(int));\r\n        write(fda[1], &num2, sizeof(int));\r\n\r\n        // 读入子进程2处理完毕的数据\r\n        int sum;\r\n        read(fdb[0], &sum, sizeof(int));\r\n        printf(\"来自子进程2的处理结果：%d\\n\", sum);\r\n        // 写入完毕，关闭写通道\r\n        close(fda[1]);\r\n        // 读取完毕，关闭读通道\r\n        close(fdb[0]);\r\n    }\r\n\r\n    // 创建第二个子进程\r\n    pid = fork();\r\n    if (pid < 0) {\r\n        print_err(\"fork\");\r\n\r\n    } else if (pid > 0) {\r\n        // 父进程不用，关闭读写通道\r\n        close(fda[0]);\r\n        close(fda[1]);\r\n        close(fdb[0]);\r\n        close(fdb[1]);\r\n        exit(0);\r\n    } else {\r\n        // 子进程2,读数据,关闭写端\r\n        close(fda[1]);\r\n        // 子进程2,写数据,关闭读端\r\n        close(fdb[0]);\r\n\r\n        int num1;\r\n        int num2;\r\n        read(fda[0], &num1, sizeof(int));\r\n        read(fda[0], &num2, sizeof(int));\r\n        printf(\"来自进程1写入的数据：num1: %d ,num2: %d\\n\", num1, num2);\r\n        // 把处理完后的数据写入b通道\r\n        int sum = num1 + num2;\r\n        write(fdb[1], &sum, sizeof(int));\r\n        // 读入完毕，关闭读通道\r\n        close(fda[0]);\r\n        // 写入完毕，关闭写通道\r\n        close(fdb[1]);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 输出\r\n```bash\r\n来自进程1写入的数据：num1: 11 ,num2: 22\r\n来自子进程2的处理结果：33\r\n来自进程1写入的数据：num1: 0 ,num2: 0\r\n```\r\n` 上面\"来自进程1写入的数据....\"为啥会输出两次？` **需要找人看下**\r\n\r\n', '2018-01-20 15:41:22', '两个进程之间通过两个半双工管道形成一个全双工管道', 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4192874692,1394407904&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C进程：进程间通信之匿名管道实现双工通信', '2018-01-20 16:45:28', '62', '4', '1', b'1'), ('59', b'1', b'1', '> 命名管道也称有名管道或FIFO管道\r\n\r\n## 概念\r\n[![命名管道(也称有名管道或FIFO管道).png](https://i.loli.net/2018/01/20/5a6302543d4e4.png)](https://i.loli.net/2018/01/20/5a6302543d4e4.png)\r\n![FIFO出错相关信息.png](https://i.loli.net/2018/01/20/5a6324adaf577.png)\r\n## 代码范例\r\n### 在当前目录创建管道文件\r\n`mkfifo pipe.txt`\r\n\r\n### 写入端代码(client.c)\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#include <memory.h>\r\n#include <unistd.h>\r\n\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(void) {\r\n    int fd = open(\"pipe.txt\", O_WRONLY);\r\n    if (fd < 0) {\r\n        print_err(\"open\");\r\n    }\r\n    char str[] = \"hello\\n\";\r\n    write(fd, str, sizeof(str));\r\n    close(fd);\r\n    return 0;\r\n}\r\n\r\n```\r\n### 读取端代码(server.c)\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#include <memory.h>\r\n#include <unistd.h>\r\n\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(void) {\r\n    int fd = open(\"pipe.txt\", O_RDONLY);\r\n    if (fd < 0) {\r\n        print_err(\"open\");\r\n    }\r\n    char buffer[10] = {\'\\0\'};\r\n    int n;\r\n    while ((n = read(fd, buffer, 10)) > 0) {\r\n        write(STDOUT_FILENO, buffer, n);\r\n    }\r\n    close(fd);\r\n    return 0;\r\n}\r\n```\r\n\r\n### 运行结果\r\n+ 运行读入端(server.c编译后的server.out),会先陷入阻塞状态\r\n![FIFO命名管道.png](https://i.loli.net/2018/01/20/5a631be681153.png)\r\n+ 运行写入端(client.c编译后的client.out),读入端可立马读取到发过来的\"hello\"消息，然后退出进程', '2018-01-20 16:53:35', '命名管道可用于任何两个进程之间的额通信，操作FIFO通道的fd和操作普通文件是完全一样地，因为管道本身就是文件系统中的一种特殊设备文件', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516448369088&di=3a8eae062f095194ae4bfaccc91d6fa2&imgtype=0&src=http%3A%2F%2Fstatic.oschina.net%2Fuploads%2Fimg%2F201306%2F17131316_OCBQ.jpg', '原创', b'1', b'1', b'1', 'Linux C进程：进程间通信之命名管道(FIFO)', '2018-01-20 19:16:52', '50', '4', '1', b'1'), ('60', b'1', b'1', '## 消息队列创建与查看\r\n### 创建\r\n```c\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <sys/msg.h>\r\n#include <errno.h>\r\n#include <memory.h>\r\n\r\n\r\ntypedef struct Msg {\r\n    int mtype;   // 消息类型\r\n    int start;   // 消息开始位置\r\n    int end;     // 消息结束位置\r\n} Msg;\r\n\r\n/**\r\n * 打印错误信息，str为自定义的错误前缀字符串\r\n */\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    if (argc < 2) {\r\n        fprintf(stderr, \"usage:%s\\n\", argv[1]);\r\n        exit(1);\r\n    }\r\n    // 生成消息队列在内存中的id\r\n    key_t key = ftok(argv[1], 1);\r\n    // 创建消息队列返回的id\r\n    int msq_id;\r\n    msq_id = msgget(key, IPC_CREAT | IPC_EXCL | 0777);\r\n    if (msq_id < 0) {\r\n        print_err(\"msgget\");\r\n    }\r\n    Msg m1 = {1, 10, 100};\r\n    Msg m2 = {2, 20, 200};\r\n    Msg m3 = {3, 30, 300};\r\n    Msg m4 = {4, 40, 400};\r\n    int id1 = msgsnd(msq_id, &m1, sizeof(m1), IPC_NOWAIT);\r\n    int id2 = msgsnd(msq_id, &m2, sizeof(m2), IPC_NOWAIT);\r\n    int id3 = msgsnd(msq_id, &m3, sizeof(m3), IPC_NOWAIT);\r\n    int id4 = msgsnd(msq_id, &m4, sizeof(m4), IPC_NOWAIT);\r\n    if (id1 < 0 || id2 < 0 || id3 < 0 || id4 < 0) {\r\n        print_err(\"msg_queue_send\");\r\n    }\r\n    struct msqid_ds msq_attr;\r\n    if (msgctl(msq_id, IPC_STAT, &msq_attr) < 0) {\r\n        print_err(\"msgctl\");\r\n    } else { // 创建消息队列成功，打印消息队列中的消息数目\r\n        printf(\"msg in queue: %ld\\n\", msq_attr.msg_qnum);\r\n        // 打印消息队列中多少个字节\r\n        printf(\"bytes in queue: %ld\\n\", msq_attr.msg_qbytes);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 运行及查看\r\n![消息队列创建与查看.png](https://i.loli.net/2018/01/21/5a64a7282634e.png)\r\n\r\n## 去除队列的消息\r\n### 代码\r\n```c\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <sys/msg.h>\r\n#include <errno.h>\r\n#include <memory.h>\r\n\r\n\r\ntypedef struct Msg {\r\n    int mtype;   // 消息类型\r\n    int start;   // 消息开始位置\r\n    int end;     // 消息结束位置\r\n} Msg;\r\n\r\n/**\r\n * 打印错误信息，str为自定义的错误前缀字符串\r\n */\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    if (argc < 3) {\r\n        fprintf(stderr, \"usage:%s\\n\", argv[0]);\r\n        exit(1);\r\n    }\r\n    // 生成消息队列在内存中的id\r\n    key_t key = ftok(argv[1], 1);\r\n    Msg m;\r\n    // 创建消息队列返回的id\r\n    int msq_id;\r\n    // 消息队列已存在，所以不用再传入 IPC_CREAT | IPC_EXCL | 0777  了\r\n    msq_id = msgget(key, 0777);\r\n    if (msq_id < 0) {\r\n        print_err(\"msgget\");\r\n    }\r\n    int type = atoi(argv[2]);  // 字符串转整型\r\n    printf(\"type: %d\\n\");\r\n    // 结果强制转换\r\n    int readResult = (int) msgrcv(msq_id, (void *) &m, sizeof(m), type, IPC_NOWAIT);\r\n    if (readResult < 0) {\r\n        print_err(\"msgrcv\");\r\n    } else {\r\n        printf(\"type: %d, start: %d, end: %d\\n\", m.mtype, m.start, m.end);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n### 取消息\r\n![消息队列消息取出.png](https://i.loli.net/2018/01/22/5a64bcef00956.png)', '2018-01-20 22:15:09', '消息队列的创建以及查看和清除消息队列的命令', 'https://i.loli.net/2018/01/20/5a634eb889f1c.png', '原创', b'1', b'1', b'1', 'Linux C进程：进程间通信之消息队列', '2018-01-22 00:17:08', '65', '4', '1', b'1'), ('61', b'1', b'1', '## 字节序转换\r\n### 判断是大端还是小端\r\n```c\r\n#include <stdio.h>\r\n#include <arpa/inet.h>\r\n\r\nint main(void) {\r\n    short a = htons(0x0102);\r\n    short *p = &a;\r\n    if (*((char *) p) == 0x01) { // 测试最低位的数据是多少\r\n        // 大端机\r\n        printf(\"big-endian\\n\");\r\n    } else if (*((char *) p) == 0x02) {\r\n        // 小端机\r\n        printf(\"little-endian\\n\");\r\n    } else {\r\n        // 未知存储方法\r\n        printf(\"unknown\\n\");\r\n    }\r\n    return 0;\r\n}\r\n```\r\n输出如下：\r\n```bash\r\nbig-endian\r\n```\r\n## 获取信息\r\n### IP地址格式转换\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n\r\nint main(void) {\r\n    // IP地址的点分十进制字符串表示形式\r\n    char addr_p[16];\r\n    // IP地址的二进制表示形式\r\n    struct in_addr addr_n;\r\n    if (inet_pton(AF_INET, \"192.168.11.6\", &addr_n) == -1) {\r\n        // 地址由字符串转换为二进制数\r\n        perror(\"fail yo convert\");\r\n        exit(1);\r\n    }\r\n    // 打印十六进制的的地址形式\r\n    printf(\"address: %x\\n\", addr_n.s_addr);\r\n\r\n    // 地址由二进制转换为点分十进制字符串\r\n    if (inet_ntop(AF_INET, &addr_n, &addr_p, sizeof(addr_p)) == -1) {\r\n        perror(\"fail to convert\");\r\n        exit(1);\r\n    }\r\n\r\n    // 打印地址的点分十进制形式\r\n    printf(\"address : %s\\n\", addr_p);\r\n    return 0;\r\n}\r\n```\r\n输出\r\n```bash\r\naddress: 60ba8c0\r\naddress : 192.168.11.6\r\n```\r\n### 获取主机相关信息\r\n```c\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <netdb.h>\r\n#include <arpa/inet.h>\r\n\r\n#define NET_ADDR 16         // 16个字节，用于存放点分十进制IP地址的字符串\r\n\r\nint main(void) {\r\n    // 存放主机信息\r\n    struct hostent *host;\r\n    // 存储点分十进制IP地址的字符串\r\n    char addr_p[NET_ADDR];\r\n    int i = 0;\r\n    // 存放主机信息\r\n    if ((host = gethostent()) == NULL) {\r\n        perror(\"fail to get host\'s information\\n\");\r\n    }\r\n    // 打印主机名\r\n    printf(\"%s\\n\", host->h_name);\r\n    // 打印主机别名\r\n    for (i = 0; host->h_aliases[i] != NULL; i++) {\r\n        printf(\"%s\\n\", host->h_aliases[i]);\r\n    }\r\n    if (host->h_addrtype == AF_INET) {\r\n        // 打印地址类型\r\n        printf(\"af_inet\\n\");\r\n    } else {\r\n        printf(\"unix_inet\");\r\n    }\r\n    // 打印地址长度\r\n    printf(\"%d\\n\", host->h_length);\r\n    // 打印主机IP地址\r\n    for (i = 0; host->h_addr_list[i] != NULL; i++) {\r\n        printf(\"%s\\n\", inet_ntop(host->h_addrtype, host->h_addr_list[i], addr_p, NET_ADDR));\r\n    }\r\n    return 0;\r\n}\r\n```\r\n输出如下：\r\n```bash\r\nlocalhost\r\naf_inet\r\n4\r\n127.0.0.1\r\n```', '2018-01-22 20:49:28', '写几个Linux网络编程中字节序转换、地址格式转换、获取主机信息的例子', 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1253142990,3226477413&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C网络编程：基础基础函数', '2018-01-23 00:36:56', '55', '4', '1', b'1'), ('62', b'1', b'1', '![服务端和客户端的通信流程](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516686986466&di=d141d8a6e1f4aa2e33896384e5ea8305&imgtype=0&src=http%3A%2F%2Fmy.bj51.org%2FUploads%2F2014_03%2Farticle%2F6e00113193.jpg \"服务端和客户端的通信流程\")\r\n## 服务端\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <string.h>\r\n#include <netdb.h>\r\n#include <unistd.h>\r\n#include <arpa/inet.h>\r\n#include <time.h>\r\n\r\n/**\r\n * 打印错误信息，str为自定义的错误前缀字符串\r\n */\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\n// socket通信被抽象成linux上的一种特殊文件系统了\r\nint sockfd;\r\n\r\nvoid out_client_info(struct sockaddr_in in) {\r\n    char buffer[16];\r\n    // 获取地址信息到buffer\r\n    inet_ntop(AF_INET, &in.sin_addr.s_addr, buffer, sizeof(in));\r\n    // 获取端口信息到port\r\n    unsigned short port = ntohs(in.sin_port);\r\n    printf(\"client ip:%s (%d)\\n\", buffer, port);\r\n}\r\n\r\nvoid do_service(int fd) {\r\n    long t = time(0);\r\n    char *s = ctime(&t);\r\n    write(fd, s, strlen(s));\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n\r\n    if (argc < 2) {\r\n        print_err(\"usage\");\r\n    }\r\n\r\n    // 1、create socket，成功返回0失败返回-1\r\n    //    参数1：AF_INET表示是IPV4协议(见P622表格23-1)\r\n    //    参数2：SOCKET_STREAM 表示是TCP通信(见P622表格23-2)\r\n    //    参数3：0代表使用地默认协议\r\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (sockfd < 0) {\r\n        printf(\"socket\");\r\n    }\r\n\r\n    // 2、set ip and port\r\n    struct sockaddr_in addr;\r\n    memset(&addr, 0, sizeof(addr));\r\n    // 指定协议族为IPV4\r\n    addr.sin_family = AF_INET;\r\n    // 设置端口\r\n    addr.sin_port = htons(atoi(argv[1]));\r\n    // 设置ip为0.0.0.0,可以接受所有来源(网页端直接访问都可以)的消息\r\n    addr.sin_addr.s_addr = INADDR_ANY;\r\n\r\n    // 3.bind ip and port\r\n    int len = sizeof(addr);\r\n    if (bind(sockfd, (struct sockaddr *) &addr, len) < 0) {\r\n        print_err(\"bind\");\r\n    }\r\n\r\n    // 4.begin to listen\r\n    if (listen(sockfd, 10) < 0) {\r\n        print_err(\"listen\");\r\n    }\r\n\r\n    // 5.accept and print\r\n    while (1) {\r\n        struct sockaddr_in client_addr;\r\n        int c_len = sizeof(client_addr);\r\n        int fd = accept(sockfd, (struct sockaddr *) &client_addr, &c_len);\r\n        if (fd < 0) {\r\n            fprintf(stderr, \"accept: %s\\n\", strerror(errno));\r\n            continue;\r\n        }\r\n        out_client_info(client_addr);\r\n        // 给客户端发送消息\r\n        do_service(fd);\r\n        // 关闭socket通信\r\n        close(fd);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n## 客户端\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <string.h>\r\n#include <netdb.h>\r\n#include <unistd.h>\r\n#include <arpa/inet.h>\r\n\r\n// socket通信被抽象成linux上的一种特殊文件系统了\r\nint sockfd;\r\n\r\nvoid print_err(char str[]) {\r\n    fprintf(stderr, \"%s: %s\\n\", str, strerror(errno));\r\n    exit(1);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n\r\n    if (argc < 3) {\r\n        print_err(\"usage\");\r\n    }\r\n\r\n    // 1、create socket，成功返回0失败返回-1\r\n    //    参数1：AF_INET表示是IPV4协议(见P622表格23-1)\r\n    //    参数2：SOCKET_STREAM 表示是TCP通信(见P622表格23-2)\r\n    //    参数3：0代表使用地默认协议\r\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (sockfd < 0) {\r\n        printf(\"socket\");\r\n    }\r\n    struct sockaddr_in sockaddr;\r\n    memset(&sockaddr, 0, sizeof(sockaddr));\r\n    sockaddr.sin_family = AF_INET;\r\n    sockaddr.sin_port = htons(atoi(argv[2]));\r\n    inet_pton(AF_INET, argv[1], &sockaddr.sin_addr.s_addr);\r\n    socklen_t len = sizeof(sockaddr);\r\n\r\n    if (connect(sockfd, (struct sockaddr *) &sockaddr, len) < 0) {\r\n        print_err(\"connect\");\r\n    }\r\n\r\n    char buffer[1024];\r\n    memset(buffer, 0, sizeof(buffer));\r\n\r\n    ssize_t n;\r\n    if ((n = read(sockfd, buffer, 1024)) < 0) {\r\n        print_err(\"read\");\r\n    } else {\r\n        printf(\"%s\\n\", buffer);\r\n    }\r\n    return 0;\r\n}\r\n```', '2018-01-23 11:30:34', 'Linux 网络通信的过程及范例，客户端和服务端通信的过程要仔细理解，服务端Accept客户端的请求后会加入到一个消息队列中，后面再依次取出请求进行挨个处理，这是一个异步的过程', 'https://www.51wendang.com/pic/f6dc069a0f39def3ec1669e0/9-229-png_6_0_0_193_753_491_258_892.979_1262.879-436-0-0-436.jpg', '原创', b'1', b'1', b'1', 'Linux C网络编程：服务端与客户端通信', '2018-01-24 00:11:48', '76', '4', '1', b'1'), ('64', b'1', b'1', '> 阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式\r\n\r\n## 同步与异步\r\n同步和异步关注的是`消息通信机制` (synchronous communication/ asynchronous communication)\r\n所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是`一旦调用返回，就得到返回值了`。换句话说，就是由**调用者**主动等待这个*调用*的结果。<br>\r\n而异步则是相反，`调用在发出之后，这个调用就直接返回了`，所以没有返回结果。换句话说，当一个异步过程调用发出后，`调用者不会立刻得到结果`。而是在调用发出后，被调用者通过**状态**、**通知**来通知调用者，或通过**回调函数**处理这个调用。<br>\r\n`举个通俗的例子`：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。\r\n\r\n', '2018-01-24 16:55:15', '阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式', 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4177335769,3698724071&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C编程：异步与同步', '2018-01-24 17:21:19', '65', '4', '1', b'1'), ('65', b'1', b'1', '> 阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式\r\n\r\n## 阻塞与非阻塞\r\n阻塞和非阻塞关注的是`程序在等待调用结果（消息，返回值）时的状态`.<br>\r\n阻塞调用是指调用结果返回之前，当前线程会被挂起。`调用线程只有在得到结果之后才会返回`。<br>\r\n非阻塞调用指在`不能立刻得到结果之前，该调用不会阻塞当前线程`。<br>\r\n`还是在同步与异步中的例子`:你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\r\n', '2018-01-24 17:20:59', '阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4233405033,186942922&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Linux C编程：阻塞与非阻塞', '2018-01-27 00:41:32', '60', '4', '1', b'1'), ('66', b'1', b'1', '> 抽时间慢慢做吧\r\n\r\n+ 预览及博客详情展示评论数\r\n+ 博客归档年份下按照月份归档\r\n+ 评论在管理员登录的时候出现一个小叉号，支持直接从博客下面点击x号删除博客评论\r\n+ 关于我添加音乐模块，用Aplayer\r\n+ markdown要支持公式编辑(后面学机器学习会有一大堆公式地),可选\r\n\r\n  + 建议原来的markdown框架[editor.md](https://github.com/pandao/editor.md)换成[stackedit](https://stackedit.io/).或者自己对后端的Markdown解析框架[commonmark-java](https://github.com/atlassian/commonmark-java)进行二次开发,使其支持`LaTex`语法.博客详情页解析MathML公式可以用第三方js库[MathJax](https://github.com/mathjax/MathJax).\r\n  + 当前编辑器也支持数学公式，见文章[Markdown 编辑器 Editor.md](https://www.oschina.net/p/editor-md)。当前的Markdown编辑器使用了[KaTeX](https://github.com/Khan/KaTeX),`可以想办法在博客详情页加以引入`', '2018-01-24 23:07:48', '未来两个月的博客开发计划', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516816506596&di=bd71f9bccd98f99cd4c627b6331845e4&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimgad%2Fpic%2Fitem%2Fac345982b2b7d0a2d056bbb9c1ef76094b369a73.jpg', '原创', b'1', b'1', b'1', '博客待完成的需求', '2018-01-27 10:36:55', '93', '1', '1', b'1'), ('67', b'1', b'1', '> 1、2、3是不可重入性转换，4、5是可重入性转换\r\n\r\n```c\r\n/**\r\n * 字符串IP地址和二进制IP地址的转换\r\n */\r\n#include <stdio.h>\r\n#include <arpa/inet.h>\r\n\r\n\r\nvoid myprint(char in[], struct in_addr result) {\r\n    printf(\"输入：%s,输出为：0x%x\\n\", in, result.s_addr);\r\n}\r\n\r\nvoid myprint2(struct in_addr in, char result[]) {\r\n    printf(\"输入：0x%x,输出为：%s\\n\", in.s_addr, result);\r\n}\r\n\r\nint main() {\r\n    struct in_addr ip, ip2, ip3;\r\n    char addr1[] = \"192.168.1.1\";\r\n    char addr2[] = \"120.79.75.27\";\r\n    char addr[16] = \"\";\r\n    char *str = NULL, *str2 = NULL;\r\n\r\n    // 1.字符串转换为二进制\r\n    inet_aton(addr1, &ip);\r\n    myprint(addr1, ip);\r\n\r\n    // 2.字符串转换为二进制\r\n    ip.s_addr = inet_addr(addr2);\r\n    myprint(addr2, ip);\r\n\r\n    // 3.二进制转换为字符串\r\n    str = inet_ntoa(ip);\r\n    myprint2(ip, str);\r\n\r\n    //4.字符串转换为二进制\r\n    inet_pton(AF_INET, addr2, &ip2);\r\n    myprint(addr2, ip2);\r\n\r\n    // 5.二进制转换为字符串\r\n    inet_ntop(AF_INET, &ip2, addr, 16);\r\n    myprint2(ip2, addr);\r\n    return 0;\r\n}\r\n```', '2018-01-27 15:00:33', 'test', 'test', '原创', b'1', b'1', b'1', 'Linux C网络编程：字符串IP和二进制IP之间的转换', '2018-01-27 15:00:33', '69', '4', '1', b'1'), ('68', b'1', b'1', '## 变量\r\n### 复杂项目的变量使用\r\n```Makefile\r\n\r\n# 1.变量声明\r\n#   1.1 编译环境变量\r\nifeq ($(DEBUG),\"true\")\r\n	# 如果是调试模式的话就用-g启动gdb\r\n	CC = gcc -g\r\nelse\r\n	CC = gcc\r\nendif\r\n#   1.2 最终的可执行文件名\r\nBIN=mp3.bin\r\n#	1.3 中间生成的.o文件(链接库)\r\nOBJS=play.o lcd.o\r\n\r\n# 2.执行编译，生成目标可执行文件\r\n#   2.1执行目标：生成可执行文件\r\nall:$(BIN)\r\n$(BIN): $(OBJS)\r\n	$(CC) -o $(BIN) $(OBJS)\r\n# 	2.2 第一个子模块\r\nplay.o:play.c\r\n	$(CC) -o play.o -c play.c\r\n#   2.3 第二个子模块\r\nlcd.o:lcd.c\r\n	$(CC) -o lcd.o -c lcd.c\r\n\r\n# 3.清理生成的库文件和可执行文件\r\nclean:\r\n	rm *.o *.bin\r\n```\r\n### 变量的运算和条件赋值\r\n```Makefile\r\nSTR = HELLO \r\nSTR2 = HELLO\r\nSTR2 += WORLD\r\n\r\ntest1 = a\r\n# 赋过值的话就不在重新赋值\r\ntest1 ?= b\r\n# 没有赋值的话就重新赋值\r\ntest2 ?= b\r\n\r\nall:\r\n	@echo \"STR = $(STR)\"\r\n	@echo \"STR2 = $(STR2)\"\r\n	@echo \"test1 = $(test1)\"\r\n	@echo \"test2 = $(test2)\"\r\n```\r\n+ 输出为：\r\n```bash\r\nSTR = HELLO\r\nSTR2 = HELLO WORLD\r\ntest1 = a\r\ntest2 = b\r\n```', '2018-02-06 01:10:18', 'Linux C编程中的Makefile的基础知识，在大型项目中尤其重要，务必好好学会', 'http://img3.imgtn.bdimg.com/it/u=1128136496,3323904563&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Makefile学习', '2018-02-06 01:12:27', '62', '4', '1', b'1'), ('69', b'1', b'1', '## P10：程序与进程\r\n```c\r\n#include \"apue.h\"\r\n\r\nint main() {\r\n    char buf[MAXLINE];\r\n    pid_t pid;\r\n    int status;\r\n    // print prompt\r\n    printf(\"%% \");\r\n    while (fgets(buf, MAXLINE, stdin) != NULL) {\r\n        if (buf[strlen(buf) - 1] == \'\\n\') {\r\n            /* replace new line with null */\r\n            buf[strlen(buf) - 1] = 0;\r\n        }\r\n        if ((pid = fork()) < 0) {\r\n            err_sys(\"fork error\");\r\n        } else if (pid == 0) {\r\n            /* 子进程 */\r\n            execlp(buf, buf, (char *) 0);\r\n            err_ret(\"couldn\'t excute: %s\", buf);\r\n            exit(127);\r\n        }\r\n        /*父进程*/\r\n        if ((pid = waitpid(pid, &status, 0)) < 0) {\r\n            err_sys(\"waitpid error\");\r\n        }\r\n        printf(\"%% \");\r\n    }\r\n    exit(0);\r\n}\r\n```\r\n## P12: 两种错误打印方式\r\n```c\r\n#include \"apue.h\"\r\n\r\nint main(int argc, char *argv[]) {\r\n    /* 错误打印方式1：根据错误号打印错误信息*/\r\n    fprintf(stderr, \"EACCESS: %s\\n\", strerror(EACCES));\r\n    errno = ENOENT;\r\n    /* 错误打印方式2：错误打印方式2*/\r\n    perror(argv[0]);\r\n    exit(0);\r\n}\r\n```\r\n## P15: 信号产生与捕获\r\n```c\r\n#include \"apue.h\"\r\n\r\n/*信号处理函数*/\r\n\r\nvoid sig_int(int signo) {\r\n    printf(\"interrupt\\n\");\r\n}\r\n\r\nint main(void) {\r\n    char buf[MAXLINE];\r\n    pid_t pid;\r\n    int status;\r\n    /*捕获异常信号*/\r\n    if (signal(SIGINT, sig_int) == SIG_ERR) {\r\n        err_sys(\"signal error\");\r\n    }\r\n    // print prompt\r\n    printf(\"%% \");\r\n    while (fgets(buf, MAXLINE, stdin) != NULL) {\r\n        if (buf[strlen(buf) - 1] == \'\\n\') {\r\n            /* replace new line with null */\r\n            buf[strlen(buf) - 1] = 0;\r\n        }\r\n        if ((pid = fork()) < 0) {\r\n            err_sys(\"fork error\");\r\n        } else if (pid == 0) {\r\n            /* 子进程 */\r\n            execlp(buf, buf, (char *) 0);\r\n            err_ret(\"couldn\'t excute: %s\", buf);\r\n            exit(127);\r\n        }\r\n        /*父进程*/\r\n        if ((pid = waitpid(pid, &status, 0)) < 0) {\r\n            err_sys(\"waitpid error\");\r\n        }\r\n        printf(\"%% \");\r\n    }\r\n    exit(0);\r\n}\r\n```', '2018-03-11 12:30:49', 'Unix高级环境编程第一章的代码，自己敲的', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=799357471,1708034021&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Unix环境高级编程：第一章--Unix基础', '2018-03-11 16:20:37', '65', '21', '1', b'1'), ('70', b'1', b'1', '## P54：测试对其标准输入能否设置偏移量\r\n```c\r\n#include \"apue.h\"\r\n\r\nint main(void) {\r\n    if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1) {\r\n        printf(\"can\'t seek\\n\");\r\n    } else {\r\n        printf(\"seek OK\\n\");\r\n    }\r\n    exit(0);\r\n\r\n}\r\n```\r\n## P55：创建一个具有空洞的文件\r\n```c\r\n#include \"apue.h\"\r\n#include <fcntl.h>\r\n\r\nchar buf1[] = \"abcdefghij\";\r\nchar buf2[] = \"ABCDEFGHIJ\";\r\n\r\nint main(void) {\r\n    int fd;\r\n    if ((fd = creat(\"file.hole\", FILE_MODE)) < 0) {\r\n        err_sys(\"create error\");\r\n    }\r\n    if (write(fd, buf1, 10) != 10) {\r\n        err_sys(\"buf1 write error\");\r\n    }\r\n    if (lseek(fd, 16384, SEEK_SET) == -1) {\r\n        err_sys(\"lseek error\");\r\n    }\r\n    if (write(fd, buf2, 10) != 10) {\r\n        err_sys(\"buf2 write error\");\r\n    }\r\n    exit(0);\r\n}\r\n```', '2018-03-11 15:40:34', 'Unix环境高级编程第三章', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=799357471,1708034021&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', 'Unix环境高级编程：第三章--文件IO', '2018-03-11 16:20:25', '49', '21', '1', b'1'), ('71', b'1', b'1', '>上面的配置能把主机名+端口的配置方式改为IP+端口的配置方式，更加合理\r\n## 自定义注册中心显示方式\r\n\r\n```yaml\r\n# 注册中心\r\neureka:\r\n  instance:\r\n      ip-address: 10.134.129.25\r\n      port: 8761\r\n      status-page-url: http://${spring.cloud.client.ipAddress}:${server.port}\r\n      instance-id: ${spring.cloud.client.ipAddress}:${spring.application.instance_id:${server.port}}\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://${eureka.instance.ip-address}:${eureka.instance.port}/eureka/\r\n\r\n```\r\n## admin-service的pom文件需要添加些东西才能跑起来\r\n\r\n```xml\r\n <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-hystrix</artifactId>\r\n        </dependency>\r\n        <!-- https://mvnrepository.com/artifact/com.netflix.zuul/zuul-core -->\r\n        <dependency>\r\n            <groupId>com.netflix.zuul</groupId>\r\n            <artifactId>zuul-core</artifactId>\r\n            <version>1.3.1</version>\r\n        </dependency>\r\n```\r\n', '2018-03-20 20:23:14', '上面的配置能把主机名+端口的配置方式改为IP+端口的配置方式，更加合理', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521558643397&di=3de732960510a96d279cb91c223fda0a&imgtype=0&src=http%3A%2F%2Fs15.sinaimg.cn%2Fmw690%2F001l8XD7zy76r0c7Xsi0e%26690', '原创', b'1', b'1', b'1', '在线学习系统的改造', '2018-03-21 10:57:59', '61', '1', '1', b'0');
COMMIT;

-- ----------------------------
--  Table structure for `t_blog_tags`
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`),
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`),
  CONSTRAINT `FK5feau0gb4lq47fdb03uboswm8` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`),
  CONSTRAINT `FKh4pacwjwofrugxa9hpwaxg6mr` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_blog_tags`
-- ----------------------------
BEGIN;
INSERT INTO `t_blog_tags` VALUES ('4', '3'), ('8', '7'), ('10', '8'), ('19', '8'), ('21', '9'), ('25', '1'), ('29', '12'), ('28', '12'), ('30', '12'), ('32', '15'), ('31', '14'), ('34', '16'), ('36', '3'), ('37', '12'), ('35', '17'), ('38', '19'), ('39', '21'), ('40', '15'), ('41', '22'), ('42', '22'), ('43', '22'), ('44', '22'), ('45', '22'), ('47', '22'), ('46', '22'), ('48', '3'), ('48', '22'), ('49', '3'), ('49', '22'), ('50', '3'), ('50', '23'), ('51', '24'), ('52', '3'), ('52', '25'), ('53', '3'), ('53', '25'), ('54', '3'), ('54', '25'), ('55', '3'), ('55', '25'), ('56', '3'), ('56', '23'), ('58', '3'), ('58', '23'), ('57', '3'), ('57', '23'), ('59', '3'), ('59', '23'), ('60', '3'), ('60', '23'), ('61', '3'), ('62', '3'), ('62', '26'), ('64', '3'), ('64', '8'), ('65', '3'), ('65', '8'), ('66', '27'), ('67', '3'), ('67', '26'), ('68', '3'), ('70', '3'), ('69', '3'), ('71', '12');
COMMIT;

-- ----------------------------
--  Table structure for `t_comment`
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin` bit(1) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`),
  KEY `FK4jj284r3pb7japogvo6h72q95` (`parent_comment_id`),
  CONSTRAINT `FK4jj284r3pb7japogvo6h72q95` FOREIGN KEY (`parent_comment_id`) REFERENCES `t_comment` (`id`),
  CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_comment`
-- ----------------------------
BEGIN;
INSERT INTO `t_comment` VALUES ('6', b'1', 'https://avatars2.githubusercontent.com/u/16741594?s=400&u=a7818e7cf3899c4b796c82bf8de8f2dab864554a&v=4', '自己写的Linux总结', '2017-12-30 16:23:55', 'liangshanguang2@gmail.com', '梁山广', '4', null), ('7', b'1', '/images/me.jpg', '未来不易，加油努力', '2017-12-31 00:12:59', 'liangshanguang2@gmail.com', '梁山广', '21', null), ('8', b'1', '/images/me.jpg', '希望能保持初心，再接再厉', '2017-12-31 00:13:27', 'liangshanguang2@gmail.com', '梁山广', '21', '7'), ('16', b'1', '/images/me.jpg', '算法第四版-第二章第4节', '2018-01-03 18:31:16', 'liangshanguang2@gmail.com', '梁山广', '25', null), ('17', b'1', '/images/me.jpg', '愿未来更好', '2018-01-12 00:10:28', 'liangshanguang2@gmail.com', '梁山广', '31', null), ('18', b'1', '/images/me.jpg', '当pthread_create第二个属性设置为PTHREAD_CREATE_JOINABLE（正常启动状态时），可以通过pthread_join函数获取结束码(可以看作是线程处理函数的的返回值)，下面的代码中为sum求和值；当设置为PTHREAD_CREATE_DETACHED时，pthread_join就没法用了', '2018-01-17 15:50:53', 'liangshanguang2@gmail.com', '梁山广', '42', null), ('19', b'1', '/images/me.jpg', '在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。', '2018-01-17 15:51:28', 'liangshanguang2@gmail.com', '梁山广', '42', null), ('20', b'1', '/images/me.jpg', '线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态（即可结合的，joinable，需要回收），这种情况下，原有的线程等待创建的线程结束；只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。', '2018-01-17 15:52:05', 'liangshanguang2@gmail.com', '梁山广', '42', null), ('21', b'1', '/images/me.jpg', '设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t *attr, int detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和 PTHREAD _CREATE_JOINABLE（非分离线程）。', '2018-01-17 15:55:02', 'liangshanguang2@gmail.com', '梁山广', '42', null), ('22', b'1', '/images/me.jpg', '这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。', '2018-01-17 15:55:09', 'liangshanguang2@gmail.com', '梁山广', '42', '21'), ('23', b'1', '/images/me.jpg', '要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。', '2018-01-17 15:55:29', 'liangshanguang2@gmail.com', '梁山广', '42', '22'), ('24', b'1', '/images/me.jpg', '一个讲分离状态属性讲地比较好的博客：http://www.cnblogs.com/mydomain/archive/2011/08/14/2138454.htm', '2018-01-17 16:09:50', 'liangshanguang2@gmail.com', '梁山广', '42', null), ('25', b'1', '/images/me.jpg', '参考文章2：https://baike.baidu.com/item/pthread_join/2296997?fr=aladdin', '2018-01-17 16:11:20', 'liangshanguang2@gmail.com', '梁山广', '42', null), ('26', b'1', '/images/me.jpg', '对条件变量讲地最好的博客：http://www.cnblogs.com/webor2006/p/4254865.html', '2018-01-18 11:53:48', 'liangshanguang2@gmail.com', '梁山广', '47', null), ('27', b'1', '/images/me.jpg', '常用前端框架： https://www.cnblogs.com/jinliu/p/6418445.html ', '2018-01-19 09:23:21', 'liangshanguang2@gmail.com', '梁山广', '51', null), ('28', b'1', '/images/me.jpg', '常用前端框架2：https://www.cnblogs.com/baisoft/p/5808926.html', '2018-01-19 09:23:40', 'liangshanguang2@gmail.com', '梁山广', '51', null), ('29', b'1', '/images/me.jpg', '上面的输出的解析：可见在主函数中调用out函数给g_a赋值22的时候，收到SIGTSTP信号进入sig_handler,给g_a覆盖赋值成了66.处理完毕又回到主函数接着赋值22.最后g_a有交叉。l_a是局部变量，在栈区。两次调用out的时是两个l_a，存在不同的区域，互不影响', '2018-01-19 14:50:40', 'liangshanguang2@gmail.com', '梁山广', '55', null), ('30', b'1', '/images/me.jpg', '两个子进程实现的双工通道为啥会输出两次啊？需要问一下', '2018-01-20 16:43:20', 'liangshanguang2@gmail.com', '梁山广', '58', null), ('31', b'0', '/images/avatar/avatar14.jpg', '偶然看到梁兄的wiki，接着被博客吸引…回首自己虚度的光阴，惭愧万分…决定从现在开始，静下心来，向梁兄学习走向优秀…', '2018-04-04 10:26:59', 'liwenjing5@huawei.com', '文静', '21', null), ('32', b'1', '/images/me.jpg', '没想到博客还有人看...谢谢谬赞，共同加油啊~嘿嘿', '2018-04-20 11:07:31', 'liangshanguang2@gmail.com', '梁山广', '21', null), ('33', b'1', '/images/me.jpg', '没想到博客还有人看...谢谢谬赞，共同加油啊~嘿嘿', '2018-04-20 11:07:56', 'liangshanguang2@gmail.com', '梁山广', '21', '32'), ('34', b'1', '/images/me.jpg', '没想到博客还有人看...谢谢谬赞，共同加油啊~嘿嘿', '2018-04-20 11:08:12', 'liangshanguang2@gmail.com', '梁山广', '21', '31'), ('35', b'0', '/images/avatar/avatar14.jpg', '<script>alert(1)</script>', '2018-06-12 18:39:56', '1234567894@qq.com', '<script>alert(1)</script>', '66', null);
COMMIT;

-- ----------------------------
--  Table structure for `t_tag`
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_tag`
-- ----------------------------
BEGIN;
INSERT INTO `t_tag` VALUES ('1', '算法第四版'), ('2', '算法导论'), ('3', 'Linux基础'), ('4', '设计模式之禅'), ('5', 'Tensorflow'), ('6', 'Caffe'), ('7', '加解密'), ('8', '文件操作'), ('9', '真话与两级'), ('12', '教程'), ('13', '林肯传'), ('14', '毕业一年半'), ('15', 'C指针'), ('16', '唐诗'), ('17', '宋词'), ('18', '摘抄'), ('19', 'Life'), ('21', 'Mac OS'), ('22', '多线程'), ('23', '进程'), ('24', 'UI框架'), ('25', '信号'), ('26', '网络编程'), ('27', '需求');
COMMIT;

-- ----------------------------
--  Table structure for `t_type`
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_type`
-- ----------------------------
BEGIN;
INSERT INTO `t_type` VALUES ('1', 'Java'), ('2', '算法'), ('3', '机器学习'), ('4', 'C/C++'), ('8', '其他'), ('9', '设计模式'), ('10', '数据库'), ('11', '生活'), ('13', 'Python'), ('17', '阅读'), ('18', '诗词'), ('19', '工具'), ('20', '前端'), ('21', 'Unix编程');
COMMIT;

-- ----------------------------
--  Table structure for `t_user`
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_user`
-- ----------------------------
BEGIN;
INSERT INTO `t_user` VALUES ('1', '/images/me.jpg', '2017-12-07 21:47:16', 'liangshanguang2@gmail.com', '梁山广', '940C0288D9B21981F667762FD1C3C021', '1', '2017-12-07 21:48:17', '梁山广');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
