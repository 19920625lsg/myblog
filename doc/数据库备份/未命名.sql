/*
 Navicat MySQL Backup

 Source Server         : root-19921023wr@120.79.75.27
 Source Server Type    : MySQL
 Source Server Version : 50720
 Source Host           : 120.79.75.27
 Source Database       : myblog

 Target Server Type    : MySQL
 Target Server Version : 50720
 File Encoding         : utf-8

 Date: 01/14/2018 15:08:05 PM
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `t_blog`
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL,
  `commendable` bit(1) NOT NULL,
  `content` longtext,
  `create_time` datetime DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommended` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `visits` int(11) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `first_picture_show` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`),
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`),
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`),
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_blog`
-- ----------------------------
BEGIN;
INSERT INTO `t_blog` VALUES ('4', b'1', b'1', '## 1. 后台启动jar 包\r\n```bash\r\nnohup java -jar myblog-backend-0.0.1-SNAPSHOT.jar &\r\n```\r\n##  2.查看跑的任务\r\n```bash\r\njobs\r\n```\r\n## 3.fg+编号,可把任务调到前台,进而手工停止程序\r\n```bash\r\nfg 1\r\n```\r\n## 4.查看端口占用\r\n```bash\r\nlsof -i:80\r\n```\r\n## 5.查看指定端口TCP连接数,比如下面是查看SSH连接数\r\n```bash\r\nnetstat -nat|grep -i \"22\"|wc -l\r\n```\r\n\r\n\r\n', '2017-12-30 00:31:32', 'Linux在日常代码开发中的常用命令，后面会不断补充地', 'http://www.embeddedlinux.org.cn/uploads/allimg/161126/09402TF4-6.jpg', '原创', b'1', b'1', b'1', 'Linux常用命令', '2017-12-30 16:24:08', '67', '8', '1', b'0'), ('8', b'1', b'1', '```java\r\npackage com.huawei.l00379880.mylib.encrypt;\r\n\r\nimport sun.misc.BASE64Decoder;\r\nimport sun.misc.BASE64Encoder;\r\n\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.DESKeySpec;\r\nimport java.io.IOException;\r\nimport java.security.SecureRandom;\r\n\r\n/***********************************************************\r\n * @Description : 加密和解密算法,用于密码读取\r\n * @author      : l00379880 梁山广\r\n * @date        : 2017/7/20 9:38\r\n * @version     : V1.0\r\n ***********************************************************/\r\n\r\n\r\npublic class EncryptAndDeEncrypt {\r\n\r\n    private final static String DES = \"DES\";\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        String data = \"123 456\";//待加密的算法\r\n        String key = \"liang!@#$%\";//要知道这个key就能解密\r\n        System.err.println(encrypt(data, key));\r\n        System.err.println(decrypt(encrypt(data, key), key));\r\n    }\r\n\r\n    /**\r\n     * Description 根据键值进行加密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    public static String encrypt(String data, String key) throws Exception {\r\n        byte[] bt = encrypt(data.getBytes(), key.getBytes());\r\n        String strs = new BASE64Encoder().encode(bt);\r\n        return strs;\r\n    }\r\n\r\n    /**\r\n     * Description 根据键值进行解密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws IOException\r\n     * @throws Exception\r\n     */\r\n    public static String decrypt(String data, String key) throws IOException,\r\n            Exception {\r\n        if (data == null) {\r\n            return null;\r\n        }\r\n        BASE64Decoder decoder = new BASE64Decoder();\r\n        byte[] buf = decoder.decodeBuffer(data);\r\n        byte[] bt = decrypt(buf, key.getBytes());\r\n        return new String(bt);\r\n    }\r\n	/**\r\n     * Description 根据键值进行加密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    private static byte[] encrypt(byte[] data, byte[] key) throws Exception {\r\n        // 生成一个可信任的随机数源\r\n        SecureRandom sr = new SecureRandom();\r\n\r\n        // 从原始密钥数据创建DESKeySpec对象\r\n        DESKeySpec dks = new DESKeySpec(key);\r\n\r\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\r\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\r\n        SecretKey securekey = keyFactory.generateSecret(dks);\r\n\r\n        // Cipher对象实际完成加密操作\r\n        Cipher cipher = Cipher.getInstance(DES);\r\n\r\n        // 用密钥初始化Cipher对象\r\n        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);\r\n\r\n        return cipher.doFinal(data);\r\n    }\r\n\r\n\r\n    /**\r\n     * Description 根据键值进行解密\r\n     *\r\n     * @param data\r\n     * @param key  加密键byte数组\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    private static byte[] decrypt(byte[] data, byte[] key) throws Exception {\r\n        // 生成一个可信任的随机数源\r\n        SecureRandom sr = new SecureRandom();\r\n\r\n        // 从原始密钥数据创建DESKeySpec对象\r\n        DESKeySpec dks = new DESKeySpec(key);\r\n\r\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\r\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\r\n        SecretKey securekey = keyFactory.generateSecret(dks);\r\n\r\n        // Cipher对象实际完成解密操作\r\n        Cipher cipher = Cipher.getInstance(DES);\r\n\r\n        // 用密钥初始化Cipher对象\r\n        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);\r\n\r\n        return cipher.doFinal(data);\r\n    }\r\n}\r\n```', '2017-12-30 19:46:56', '加密和解密算法,基于JDK自带的BASE64算法，一般用于密码读取', 'https://deeplearning4j.org/img/mnist_render.png', '原创', b'1', b'1', b'1', 'Java实现BASE64加密', '2017-12-30 20:18:29', '6', '1', '1', b'1'), ('10', b'1', b'1', '```java\r\n/***********************************************************\r\n* @Title       : MyFile.java\r\n* @Package     : lsg.huawei.file\r\n* @Description : 最常用的文件操作，关键在于读取中文没问题！！\r\n* @author      : l00379880 梁山广\r\n* @date        : 2016-12-9 上午08:35:06\r\n* @version     : V1.0\r\n***********************************************************/\r\npackage com.huawei.l00379880.mylib.file;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.TreeSet;\r\n\r\n/***********************************************************\r\n * @ClassName   : MyFile\r\n * @Description : TODO(这里用一句话描述这个类的作用)\r\n * @author      : l00379880 梁山广\r\n * @date        : 2016-12-9 上午08:35:06\r\n ***********************************************************/\r\npublic class MyFile\r\n{\r\n	public static ArrayList<String> readFilesUnderFolder(String filepath,String suffix)	\r\n	{\r\n		ArrayList<String> filePathList = new ArrayList<String>();\r\n		File file = new File(filepath);\r\n		if (!file.isDirectory())\r\n		{\r\n			System.out.println(\"输入参数必须是一个文件夹的路径！\");\r\n\r\n		} else if (file.isDirectory())\r\n		{\r\n			String[] filelist = file.list();\r\n			for (int i = 0; i < filelist.length; i++)\r\n			{\r\n				File readfile = new File(filepath + \"\\\\\" + filelist[i]);\r\n				if (!readfile.isDirectory())// 只处理是文件的路径,是文件夹的涉及到下面的递归查找了，后面单独实现\r\n				{\r\n					String totalPath=readfile.getAbsolutePath();\r\n//					System.out.println(totalPath);\r\n					String baseName = readfile.getName();\r\n					if(baseName.endsWith(suffix))\r\n					{\r\n						filePathList.add(totalPath);\r\n					}\r\n				}\r\n			}\r\n		}\r\n		return filePathList;\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readFilesUnderFolderCursively\r\n	* @Description: 递归查找指定路径下指定后缀的所有文件\r\n	* @param      : @param filepath\r\n	* @param      : @param suffix\r\n	* @param      : @return\r\n	* @return     ：  ArrayList<String> 返回类型 ：\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 下午11:31:41\r\n	*************************************************************/\r\n	public static ArrayList<String> readFilesUnderFolderCursively(String filepath,String suffix)//先写文件再读文件就好了\r\n	{\r\n		ArrayList<String> filePathList = new ArrayList<String>();\r\n		readFilesUnderFolderCursivelySon(filepath,suffix);\r\n		filePathList =readLineStrings(System.getProperty(\"user.dir\")+\"\\\\temp.txt\");\r\n		delete(System.getProperty(\"user.dir\")+\"\\\\temp.txt\");\r\n		return filePathList;\r\n	}\r\n	public static ArrayList<String> readFilesUnderFolderCursively(String filepath,String suffix,String encoding)//先写文件再读文件就好了\r\n	{\r\n		ArrayList<String> filePathList = new ArrayList<String>();\r\n		System.out.println(filepath);\r\n		readFilesUnderFolderCursivelySon(filepath,suffix,encoding);\r\n\r\n		filePathList =readLineStrings(System.getProperty(\"user.dir\")+\"\\\\temp.txt\",encoding);\r\n		delete(System.getProperty(\"user.dir\")+\"\\\\temp.txt\");\r\n		return filePathList;\r\n	}\r\n	 /**\r\n     * 读取某个文件夹下的所有指定后缀类型的文件，递归查找,因为每一次递归都会重新创建一个list，所以只能靠引用传值\r\n     */\r\n	public static void readFilesUnderFolderCursivelySon(String filepath,String suffix)\r\n	{\r\n		File file = new File(filepath);\r\n		if (!file.isDirectory())\r\n		{\r\n			System.out.println(\"输入参数必须是一个文件夹的路径！\");\r\n\r\n		} else if (file.isDirectory())\r\n		{\r\n			String[] filelist = file.list();\r\n			for (int i = 0; i < filelist.length; i++)\r\n			{\r\n				File readfile = new File(filepath + \"\\\\\" + filelist[i]);\r\n				if (!readfile.isDirectory())//如果是路径的话\r\n				{\r\n					String totalPath=readfile.getAbsolutePath();\r\n					if(totalPath.endsWith(suffix))\r\n					{\r\n//						System.out.println(totalPath);\r\n						fileAppend(System.getProperty(\"user.dir\")+\"\\\\temp.txt\", \"GBK\", totalPath);//追加要用GBK才能写入中文哦！！\r\n					}\r\n\r\n				} else if (readfile.isDirectory())\r\n				{\r\n					readFilesUnderFolderCursivelySon(filepath + \"\\\\\" + filelist[i], suffix);//递归查找\r\n				}\r\n			}\r\n\r\n		}\r\n	}\r\n	/**\r\n     * 读取某个文件夹下的所有指定后缀类型的文件，递归查找,因为每一次递归都会重新创建一个list，所以只能靠引用传值\r\n     */\r\n	public static void readFilesUnderFolderCursivelySon(String filepath,String suffix,String encoding)\r\n	{\r\n		File file = new File(filepath);\r\n		if (!file.isDirectory())\r\n		{\r\n			System.out.println(\"输入参数必须是一个文件夹的路径！\");\r\n\r\n		} else if (file.isDirectory())\r\n		{\r\n			String[] filelist = file.list();\r\n			for (int i = 0; i < filelist.length; i++)\r\n			{\r\n				File readfile = new File(filepath + \"\\\\\" + filelist[i]);\r\n				if (!readfile.isDirectory())//如果是路径的话\r\n				{\r\n					String totalPath=readfile.getAbsolutePath();\r\n					if(totalPath.endsWith(suffix))\r\n					{\r\n//						System.out.println(totalPath);\r\n						fileAppend(System.getProperty(\"user.dir\")+\"\\\\temp.txt\", encoding, totalPath);//追加要用GBK才能写入中文哦！！\r\n					}\r\n\r\n				} else if (readfile.isDirectory())\r\n				{\r\n					readFilesUnderFolderCursivelySon(filepath + \"\\\\\" + filelist[i], suffix);//递归查找\r\n				}\r\n			}\r\n\r\n		}\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readLineStrings\r\n	* @Description: 按行从文件中读取内容到字符串list\r\n	* @param      : @param filePath\r\n	* @param      : @return\r\n	* @return     ：  ArrayList<String> 返回从文件中督导的字符串list\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-9 上午08:36:14\r\n	*************************************************************/\r\n	public static ArrayList<String> readLineStrings(String filePath)\r\n	{\r\n		ArrayList<String> list=new ArrayList<String>();\r\n		String str = \"\";\r\n		FileInputStream fis = null;\r\n		InputStreamReader isr = null;\r\n		BufferedReader br = null; // 用于包装InputStreamReader,提高处理性能。因为BufferedReader有缓冲的，而InputStreamReader没有。\r\n		try\r\n		{\r\n			fis = new FileInputStream(filePath);// FileInputStream\r\n			// 从文件系统中的某个文件中获取字节\r\n			isr = new InputStreamReader(fis,\"UTF-8\");// InputStreamReader 是字节流通向字符流的桥梁,\r\n			br = new BufferedReader(isr);// 从字符输入流中读取文件中的内容,封装了一个new\r\n											// InputStreamReader的对象\r\n			while ((str = br.readLine()) != null)\r\n			{\r\n				list.add(str);\r\n			}\r\n		} catch (FileNotFoundException e)\r\n		{\r\n		System.out.println(\"找不到指定文件\");\r\n\r\n	} catch (IOException e)\r\n	{\r\n		System.out.println(\"读取文件失败\");\r\n	} finally\r\n	{\r\n		try\r\n		{\r\n			br.close();\r\n			isr.close();\r\n			fis.close();\r\n			// 关闭的时候最好按照先后顺序关闭最后开的先关闭所以先关s,再关n,最后关m\r\n		} catch (IOException e)\r\n		{\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n	return list;//返回list\r\n}\r\n/*************************************************************\r\n* @Title      : readLineStrings\r\n* @Description: 按照指定的编码格式从文件中逐行读入数据到List，重载了一种方式\r\n* @param      : @param filePath\r\n* @param      : @param encoding:指定的编码格式\r\n* @param      : @return\r\n* @return     ：  ArrayList<String> 返回类型\r\n* @author     : l00379880 梁山广\r\n* @date       : 2016年12月17日 下午11:29:04\r\n*************************************************************/\r\npublic static ArrayList<String> readLineStrings(String filePath,String encoding)\r\n{\r\n	ArrayList<String> list=new ArrayList<String>();\r\n	String str = \"\";\r\n	FileInputStream fis = null;\r\n	InputStreamReader isr = null;\r\n	BufferedReader br = null; // 用于包装InputStreamReader,提高处理性能。因为BufferedReader有缓冲的，而InputStreamReader没有。\r\n	try\r\n	{\r\n		fis = new FileInputStream(filePath);// FileInputStream\r\n		// 从文件系统中的某个文件中获取字节\r\n		isr = new InputStreamReader(fis,encoding);// InputStreamReader 是字节流通向字符流的桥梁,\r\n		br = new BufferedReader(isr);// 从字符输入流中读取文件中的内容,封装了一个new\r\n										// InputStreamReader的对象\r\n		while ((str = br.readLine()) != null)\r\n		{\r\n			list.add(str);\r\n		}\r\n	} catch (FileNotFoundException e)\r\n	{\r\n		System.out.println(\"找不到指定文件\");\r\n\r\n	} catch (IOException e)\r\n	{\r\n		System.out.println(\"读取文件失败\");\r\n	} finally\r\n	{\r\n		try\r\n		{\r\n			br.close();\r\n			isr.close();\r\n			fis.close();\r\n			// 关闭的时候最好按照先后顺序关闭最后开的先关闭所以先关s,再关n,最后关m\r\n		} catch (IOException e)\r\n		{\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n	return list;//返回list\r\n}\r\n/*************************************************************\r\n	* @Title      : readLineStringsSet\r\n	* @Description: 从文件中读取数据到集合set中，方便后面进行集合的运算\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding\r\n	* @param      : @return\r\n	* @return     ：  TreeSet<String> 返回类型 ：rb文件的路径集合\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016年12月22日 下午2:00:53\r\n	*************************************************************/\r\n	public static TreeSet<String> readLineStringsSet(String filePath,String encoding)\r\n	{\r\n		 TreeSet<String> set=new TreeSet<String>();\r\n		String str = \"\";\r\n		FileInputStream fis = null;\r\n		InputStreamReader isr = null;\r\n		BufferedReader br = null; // 用于包装InputStreamReader,提高处理性能。因为BufferedReader有缓冲的，而InputStreamReader没有。\r\n		try\r\n		{\r\n			fis = new FileInputStream(filePath);// FileInputStream\r\n			// 从文件系统中的某个文件中获取字节\r\n			isr = new InputStreamReader(fis,encoding);// InputStreamReader 是字节流通向字符流的桥梁,\r\n			br = new BufferedReader(isr);// 从字符输入流中读取文件中的内容,封装了一个new\r\n											// InputStreamReader的对象\r\n			while ((str = br.readLine()) != null)\r\n			{\r\n				set.add(str);\r\n			}\r\n		} catch (FileNotFoundException e)\r\n		{\r\n			System.out.println(\"找不到指定文件\");\r\n\r\n		} catch (IOException e)\r\n		{\r\n			System.out.println(\"读取文件失败\");\r\n		} finally\r\n		{\r\n			try\r\n			{\r\n				br.close();\r\n				isr.close();\r\n				fis.close();\r\n				// 关闭的时候最好按照先后顺序关闭最后开的先关闭所以先关s,再关n,最后关m\r\n			} catch (IOException e)\r\n			{\r\n				e.printStackTrace();\r\n			}\r\n		}\r\n		return set;//返回list\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readAlltoHTML\r\n	* @Description: 把文本文件中的全部内容读取到一个StringBuilder中\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016年12月20日 下午8:43:00\r\n	*************************************************************/\r\n	public static String readAlltoHTML(String filePath,String encoding)\r\n	{\r\n		StringBuilder result = new StringBuilder(\"\");//新建结果字符串\r\n		ArrayList<String> contentLines = readLineStrings(filePath, encoding);//把脚本文件读取过来\r\n		for(String line:contentLines)\r\n		{\r\n			result.append(line+\"<br>\");\r\n		}\r\n		return result.toString();\r\n	}\r\n	/*************************************************************\r\n	* @Title      : readAll\r\n	* @Description: 一次性把文件内容都读到一个ts文件夹\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年2月13日 下午7:35:19\r\n	*************************************************************/\r\n	public static String readAll(String filePath,String encoding)\r\n	{\r\n		StringBuilder result = new StringBuilder(\"\");//新建结果字符串\r\n		ArrayList<String> contentLines = readLineStrings(filePath, encoding);//把脚本文件读取过来\r\n		for(String line:contentLines)\r\n		{\r\n			result.append(line+\"\\n\");\r\n		}\r\n		return result.toString();\r\n	}\r\n	/*************************************************************\r\n	* @Title      : fileAppend\r\n	* @Description: 向文件中追加内容，删除需要自己额外操作\r\n	* @param      : @param filePath\r\n	* @param      : @param encoding：最好用UTF-8模式\r\n	* @param      : @param content\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 下午11:21:52\r\n	*************************************************************/\r\n	public static void fileAppend(String filePath,String encoding,String content)\r\n	{\r\n		BufferedWriter out = null;\r\n		try\r\n		{\r\n			out = new BufferedWriter(new OutputStreamWriter(\r\n					new FileOutputStream(filePath, true),encoding));\r\n			out.write(content + \"\\r\\n\");\r\n		} catch (Exception e)\r\n		{\r\n			e.printStackTrace();\r\n		} finally\r\n		{\r\n			try\r\n			{\r\n				out.close();\r\n			} catch (IOException e)\r\n			{\r\n				e.printStackTrace();\r\n			}\r\n		}\r\n\r\n	}\r\n\r\n	/*************************************************************\r\n	* @Title      : fileWrite\r\n	* @Description: 向文件中写入自定义内容，兼容中文，如果文件原来存在\r\n	*               会先删除的，适合一次性写入日志\r\n	* @param      : @param filePath 文件路径\r\n	* @param      : @param encoding 编码\r\n	* @param      : @param content  待写入的内容\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-8 下午11:00:12\r\n	*************************************************************/\r\npublic static void fileWrite(String filePath,String encoding,String content)\r\n	{\r\n		File file = new File(filePath);\r\n		if(file.exists())\r\n		{\r\n			file.delete();//结果文件存在的话先删除，适合写入日志\r\n		}\r\n		if (!file.getParentFile().exists())\r\n		{\r\n			file.getParentFile().mkdirs();\r\n			System.out.println(\"文件夹\"+file.getParentFile()+\"原来不存在，已经新建好了！\");\r\n		}\r\n\r\n		try\r\n		{\r\n			file.createNewFile();\r\n//			System.out.println(filePath+\"原来不存在，已经创建成功！\");\r\n		} catch (IOException e)\r\n		{\r\n			e.printStackTrace();\r\n			System.out.println(filePath+\"创建文件失败唉\");\r\n		}\r\n		try\r\n		{\r\n//			FileOutputStream out = new FileOutputStream(file);\r\n			BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\r\n				    new FileOutputStream(file), encoding));\r\n//			byte buy[] = tcContent.getBytes();// 以字节流的方式写入到文件中\r\n//			out.write(buy);\r\n			out.write(content);\r\n			out.close();\r\n//			System.out.println(\"-----------------\"+filePath+\"----------写入成功！\");\r\n		} catch (FileNotFoundException e)\r\n		{\r\n			System.out.println(filePath+\"写入文件内容失败！文件未找到的错误如下：\");\r\n			e.printStackTrace();\r\n		} catch (IOException e)\r\n		{\r\n			System.out.println(filePath+\"写入文件内容失败！流错误如下：\");\r\n			e.printStackTrace();\r\n		}\r\n\r\n	}\r\n	/*************************************************************\r\n	* @Title      : exists\r\n	* @Description: 判断文件是够存在\r\n	* @param      : @param filePath\r\n	* @param      : @return\r\n	* @return     ：  boolean 返回类型 :存在的话就返回true\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 上午11:46:04\r\n	*************************************************************/\r\n	public static boolean exists(String filePath)\r\n	{\r\n		boolean exists = false;\r\n		File file = new File(filePath);\r\n		if(file.exists())\r\n		{\r\n			exists = true;\r\n		}\r\n		return exists;\r\n	}\r\n/*************************************************************\r\n	* @Title      : delete\r\n	* @Description: 删除指定文件/文件夹\r\n	* @param      : @param filePath\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016-12-12 下午11:14:38\r\n	*************************************************************/\r\n	public static void delete(String filePath)\r\n	{\r\n		File file = new File(filePath);\r\n		if(file.exists())\r\n		{\r\n//			System.out.println(\"文件存在的！！\");\r\n			file.delete();\r\n		}\r\n	}\r\n	/*************************************************************\r\n	* @Title      : changeCharset\r\n	* @Description: 将字符串的集合进行转化\r\n	* @param      : @param str\r\n	* @param      : @param fromCharset\r\n	* @param      : @param toCharset\r\n	* @param      : @return\r\n	* @param      : @throws Throwable\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2016年12月23日 上午9:21:18\r\n	*************************************************************/\r\n	public static String changeCharset(String str,String fromCharset,String toCharset) throws Throwable\r\n	{\r\n		return new String(str.getBytes(\"GBK\"), \"UTF-8\");\r\n	}\r\n	/*************************************************************\r\n	* @Title      : getBaseName\r\n	* @Description: TODO(这里用一句话描述这个方法的作用)\r\n	* @param      : @param filePath\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型 :返回取出的文件名\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年1月14日 下午10:47:43\r\n	*************************************************************/\r\n	public static String getBaseName(String filePath)\r\n	{\r\n		return filePath.substring(filePath.lastIndexOf(\"\\\\\")+1, filePath.lastIndexOf(\".\"));\r\n	}\r\n	/*************************************************************\r\n	* @Title      : getRelativePath\r\n	* @Description: 根据文件路径和根路径得到相对路径\r\n	* @param      : @param filePath\r\n	* @param      : @param rootPath\r\n	* @param      : @return\r\n	* @return     ：  String 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年1月14日 下午10:50:38\r\n	*************************************************************/\r\n	public static String getRelativePath(String filePath,String rootPath)\r\n	{\r\n		return filePath.replace(rootPath, \"\");//直接把路径的无用部分剔除掉\r\n	}\r\n\r\n	//删除文件夹\r\n	//param folderPath 文件夹完整绝对路径\r\n\r\n    /*************************************************************\r\n	* @Title      : delFolder\r\n	* @Description: 删除指定文件夹\r\n	* @param      : @param folderPath\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年2月14日 上午8:34:04\r\n	*************************************************************/\r\npublic static void delFolder(String folderPath)\r\n	  {\r\n	     try\r\n	     {\r\n	        delAllFile(folderPath); //删除完里面所有内容\r\n	        String filePath = folderPath;\r\n	        filePath = filePath.toString();\r\n	        File myFilePath = new File(filePath);\r\n	        myFilePath.delete(); //删除空文件夹\r\n	     } catch (Exception e)\r\n	     {\r\n	       e.printStackTrace();\r\n	     }\r\n	  }\r\n\r\n	//删除指定文件夹下所有文件\r\n	//param path 文件夹完整绝对路径\r\n	   public static boolean delAllFile(String path) {\r\n	       boolean flag = false;\r\n	       File file = new File(path);\r\n	       if (!file.exists()) {\r\n	         return flag;\r\n	       }\r\n	       if (!file.isDirectory()) {\r\n	         return flag;\r\n	       }\r\n	       String[] tempList = file.list();\r\n	       File temp = null;\r\n	       for (int i = 0; i < tempList.length; i++) {\r\n	          if (path.endsWith(File.separator)) {\r\n	             temp = new File(path + tempList[i]);\r\n	          } else {\r\n	              temp = new File(path + File.separator + tempList[i]);\r\n	          }\r\n	          if (temp.isFile()) {\r\n	             temp.delete();\r\n	          }\r\n	          if (temp.isDirectory()) {\r\n	             delAllFile(path + \"/\" + tempList[i]);//先删除文件夹里面的文件\r\n	             delFolder(path + \"/\" + tempList[i]);//再删除空文件夹\r\n	             flag = true;\r\n	          }\r\n	       }\r\n	       return flag;\r\n	     }\r\n\r\n	   /*************************************************************\r\n		* @Title      : deleteFolder\r\n		* @Description: 删除文件夹\r\n		* @param      : @param folderPath\r\n		* @return     ：  void 返回类型\r\n		* @author     : l00379880 梁山广\r\n		* @date       : 2017年2月15日 下午3:49:57\r\n		*************************************************************/\r\n		public static void deleteFolder(String folderPath)\r\n	    {\r\n			Delete fileDetele = new Delete();\r\n			fileDetele.deleteFolder(\"D:\\\\MyProjects\\\\MyEclipse\\\\ScriptAutoGen\\\\results\\\\eSAP\\\\V200R002C30\\\\IKE\");\r\n	    }\r\n\r\n\r\n	/*************************************************************\r\n	* @Title      : reNameSuffix\r\n	* @Description: 对特定文件重命名,只修改后缀即可\r\n	* @param      : @param srcPath:原来的文件路径\r\n	* @param      : @param dstSuffix：要修改成的文件后缀,后缀为空就是去掉后缀\r\n	* @return     ：  void 返回类型\r\n	* @author     : l00379880 梁山广\r\n	* @date       : 2017年3月9日 上午9:24:25\r\n	*************************************************************/\r\n	public static void reNameSuffix(String srcPath, String dstSuffix)\r\n	{\r\n		File file = new File(srcPath); // 指定文件名及路径\r\n		String filename = srcPath.substring(0, srcPath.lastIndexOf(\".\"));\r\n		if(dstSuffix.equals(\"\")||dstSuffix==null)\r\n		{\r\n			file.renameTo(new File(filename)); // 如果后缀为空表名要去掉后缀\r\n		}\r\n		file.renameTo(new File(filename + \".\" + dstSuffix)); // 改名\r\n	}\r\n```', '2017-12-30 19:57:57', '我自己的通用Java文件读写类,实现了文件读取到list、递归读取文件夹下所有文件完整路径到list、递归删除文件夹下所有文件、判断文件是否存在等,并完美解决了中文乱码问题', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514645125617&di=49770ef2a7b8ffe15154ab5f380c9d0c&imgtype=0&src=http%3A%2F%2Fpic.58pic.com%2F58pic%2F15%2F56%2F91%2F33d58PICYGr_1024.png', '原创', b'1', b'1', b'1', 'Java通用文件操作类', '2017-12-30 20:24:54', '7', '1', '1', b'1'), ('19', b'1', b'1', '```java\r\npackage com.huawei.l00379880.mylib.file;\r\n\r\nimport java.io.File;\r\n\r\n/***********************************************************\r\n* @ClassName   : Delete\r\n* @Description : 文件/文件夹的删除类\r\n* @author      : l00379880 梁山广\r\n* @date        : 2017年2月15日 下午3:42:04\r\n***********************************************************/\r\npublic class Delete\r\n{\r\n	private static String matches = \"[A-Za-z]:\\\\\\\\[^:?\\\"><*]*\";\r\n	boolean flag = false;\r\n	File file;\r\n	public boolean deleteFolder(String deletePath) {// 根据路径删除指定的目录或文件，无论存在与否\r\n		flag = false;\r\n		if (deletePath.matches(matches)) {\r\n			file = new File(deletePath);\r\n			if (!file.exists()) {// 判断目录或文件是否存在\r\n				return flag; // 不存在返回 false\r\n			} else {\r\n\r\n				if (file.isFile()) {// 判断是否为文件\r\n					return deleteFile(deletePath);// 为文件时调用删除文件方法\r\n				} else {\r\n					return deleteDirectory(deletePath);// 为目录时调用删除目录方法\r\n				}\r\n			}\r\n		} else {\r\n			System.out.println(\"要传入正确路径！\");\r\n			return false;\r\n		}\r\n	}\r\n	public boolean deleteFile(String filePath) {// 删除单个文件\r\n		flag = false;\r\n		file = new File(filePath);\r\n		if (file.isFile() && file.exists()) {// 路径为文件且不为空则进行删除\r\n			file.delete();// 文件删除\r\n			flag = true;\r\n		}\r\n		return flag;\r\n	}\r\n\r\n	public boolean deleteDirectory(String dirPath) {// 删除目录（文件夹）以及目录下的文件\r\n		// 如果sPath不以文件分隔符结尾，自动添加文件分隔符\r\n		if (!dirPath.endsWith(File.separator)) {\r\n			dirPath = dirPath + File.separator;\r\n		}\r\n		File dirFile = new File(dirPath);\r\n		// 如果dir对应的文件不存在，或者不是一个目录，则退出\r\n		if (!dirFile.exists() || !dirFile.isDirectory()) {\r\n			return false;\r\n		}\r\n		flag = true;\r\n		File[] files = dirFile.listFiles();// 获得传入路径下的所有文件\r\n		for (int i = 0; i < files.length; i++) {// 循环遍历删除文件夹下的所有文件(包括子目录)\r\n			if (files[i].isFile()) {// 删除子文件\r\n				flag = deleteFile(files[i].getAbsolutePath());\r\n//				System.out.println(files[i].getAbsolutePath() + \" 删除成功\");\r\n				if (!flag) {\r\n                    break;// 如果删除失败，则跳出\r\n                }\r\n			} else {// 运用递归，删除子目录\r\n				flag = deleteDirectory(files[i].getAbsolutePath());\r\n				if (!flag) {\r\n                    break;// 如果删除失败，则跳出\r\n                }\r\n			}\r\n		}\r\n//		System.out.println(dirPath+\"删除成功！\");\r\n		if (!flag) {\r\n            return false;\r\n        }\r\n		if (dirFile.delete()) {// 删除当前目录\r\n			return true;\r\n		} else {\r\n			return false;\r\n		}\r\n	}\r\n}\r\n\r\n```', '2017-12-30 20:37:54', '自己实现的递归删除文件夹下所有文件的类', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514648045569&di=e0ffda888e0b77c9e3551e5e0b1e3d31&imgtype=0&src=http%3A%2F%2Fpic.58pic.com%2F58pic%2F15%2F87%2F47%2F39a58PICycS_1024.jpg', '原创', b'1', b'1', b'1', 'Java删除文件夹', '2017-12-31 00:36:48', '14', '1', '1', b'0'), ('21', b'1', b'1', '转眼之间，已经毕业一年多了，这一年，经历了太多太多。\r\n### 恰同学少年\r\n15年9月，貌似我的校招特别顺利，华为给我开了特殊起薪还专门请我们SP吃饭，永远忘不了刚面试完华为一小时，导员激动地给我说华为校招的老大拍板说会给我会加很多特殊起薪，让我千万别签别的公司。加上面试的人简直让我相见恨晚，自此边认定了华为，校招也几乎还没开始就结束了。\r\n### 直面现实\r\n16年6月底,拿到毕业证的第三天就只身一人拽着一箱书来到了千里之外的南京.<br>\r\n从出生到大学毕业,除了一次坐公交睡着坐过站到了河北外,还从没出过省.<br>\r\n听说南京房价在我来前半年的时间,从两万涨到了四万.<br>\r\n听说华为会随机分配,比如答应我去做算法,最后分到了测试.<br>\r\n听说我司经常会加班,比如半夜过点.<br>\r\n听说工作后人会变得很圆滑,最终会变成自己讨厌的样子.<br>\r\n听说.....<br>\r\n当所有的听说变成赤裸裸的现实,突然觉得曾经的努力在现实面前,是那么苍白.<br>\r\n还未配好剑,转身已是江湖.\r\n### 那些忙碌而快乐的日子\r\n入职后,得知转岗的难度后,问了HR一句,<br>\r\n\"测试部有写代码的部门吗?\"<br>\r\n\"自动化主要写代码,不过比较杂,什么语言都用\".<br>\r\n\"那我就去自动化\"<br>\r\n后来在在自动化一年先后用过Java、Ruby、Python、C#、VBA...<br>\r\n曾经和主管晓华哥、师傅天名哥还有柯东哥,经常一起happy地吃完18块的自助后回来欢实地加班到11点...<br>\r\n巅峰时期一周四顿自助,后来自助被我们吃倒闭了...<br>\r\n后来在胖了整整胖了20斤的那天,拿到了优秀新员工<br>\r\n后来晓华哥去了阿里,柯东哥去了华三,烦闷的某天,来到我师父那,开玩笑似地问了一句<br>\r\n\"师傅,你是不是也要走?\"<br>\r\n\"嘘!你咋知道\"师傅一脸震惊+懵逼<br>\r\n\"我不知道啊\"<br>\r\n然后师傅去了网易.<br>\r\n.......................................................................<br>\r\n无比怀念四个人胡吃海喝的日子.<br>\r\n原来以为学校中的离别是最让人伤心的.现在才发现职场的离别更残酷.<br>\r\n起码学校的离别是可期的,但在职场中,你要做好随时目送身边朋友们离开的准备<br>\r\n### 因为\"真话\"而改变的命运\r\n不曾想到一个花了两分钟写地帖子会让公司震动两个月,也不曾想到一句略带戏谑的呼喊会演变成一场全公司范围内的整风运动.<br>\r\n两个月,无日不在战战兢兢、如履薄冰.<br>\r\n然后是平静生活中的一声惊雷,<br>\r\n这辈子都没敢奢望过会有交集的任总亲自发文支持我<br>\r\n然后是连升两级、加薪、配股.<br>\r\n开心吗?<br>\r\n不开心是假的,但开心维持了不超过一天.<br>\r\n先是头条,然后是网易、UC、百度、微博热搜,第二天开始到了东方卫视、江西电视台、深圳电视台、无数的自媒体、北京青年报、人民日报........<br>\r\n事情的发酵程度远远超出了我的想象,从心声\"达人\"变成了社会\"网红\"<br>\r\n终于知道舆论的可怕,它们黑白不分、颠倒是非,为了博人眼球群起而诋毁之<br>\r\n一个被符号化的人是很难存在于现实中的.<br>\r\n很多在我说真话时的怂恿者,变成了升两级之后的诋毁者.<br>\r\n人言可畏,人心可恨.<br>\r\n很多人会期望你替他们出头,却见不得你因此而得到好的结果<br>\r\n于是乎,原来漫山遍野的支持者、欢呼者、怂恿者,变成了质疑者、嫉妒者、嘲弄者.<br>\r\n终于知道孔令贤前辈为何逃离华为.<br>\r\n只因单薄的肩膀承担不起充满劣根性的小人的诽谤.<br>\r\n单纯的技术人在华为是很难生存下去的,因为越是想突出的人,越会被无数双挑剔的眼睛盯着.<br>\r\n### 后\"网红\"的日子\r\n过去三个月,经历了太多太多,心态也逐渐平和,终于能静下心来好好看看书、写写代码.<br>\r\n心声也被我重定向到localhost了.<br>\r\n告别那些戾气满满的日子,未来好好加油!<br>\r\n----------------------------------------------2017-11-05 14:26 于华为上海研究所-----------------------------------------------\r\n', '2017-12-31 00:11:35', '我们要鼓励员工及各级干部讲真话，真话有正确的、不正确的，各级组织采纳不采纳，并没什么问题，而是风气要改变', 'https://img.huxiucdn.com/article/cover/201709/08/084247486452.png', '原创', b'1', b'1', b'1', '我来华为的一年', '2017-12-31 00:37:03', '21', '11', '1', b'1'), ('25', b'1', b'1', '## 概念阐述\r\n### 完全二叉树\r\n>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\r\n   \r\n### 堆有序\r\n>当一颗完全二叉树的每个节点都大于(或小于)等于他的两个子节点时,被称为堆有序\r\n   \r\n### 二叉堆\r\n>一组能够用堆有序的完全二叉树排序的元素\r\n\r\n### 最大堆\r\n>每个节点都大于等于他的两个子节点的二叉堆\r\n\r\n### 最小堆\r\n>每个节点都小于等于他的两个子节点的二叉堆\r\n', '2018-01-03 17:52:08', '学习优先队列和堆排序的过程中,老是和算法中的二叉查找树混淆,因此专门来总结下容易混淆的概念。并结合代码进行详细分析和讲解', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514983044736&di=1488d67e60740e5aa1d61aaefe8b99e1&imgtype=0&src=http%3A%2F%2Fimages.cnitblog.com%2Fi%2F606550%2F201403%2F051251148735812.jpg', '原创', b'1', b'1', b'1', '优先队列与堆排序解析', '2018-01-03 21:52:42', '12', '2', '1', b'1'), ('26', b'0', b'1', '* >pq[i]代表在elements中第i大的元素在elements中的下标是pq[i]\r\n* > qp[i]代表在elements中第i个元素在elements中是第pq[i]大', '2018-01-03 21:55:13', '关于索引优先队列,其中的pq进而qp绕来绕去很烦了,找了一篇不错的博客,可以参考下', 'http://chuantu.biz/t6/195/1515030371x-1404793260.jpg', '原创', b'1', b'1', b'1', '索引优先队列', '2018-01-12 21:46:06', '24', '2', '1', b'1'), ('28', b'1', b'1', '> 利用IDEA编辑器的Live Templates可以实现自定义方法、属性、注释等，下面是我自己的常用模板。\r\n\r\n\r\n## 属性模板\r\n### pri : private int 类型属性声明\r\n```java\r\nprivate int $END$;\r\n```\r\n### prs : private String 类型属性声明\r\n```java\r\nprivate String $END$;\r\n```\r\n## 函数模板\r\n### pub : public boolean 方法声明\r\n```java\r\npublic boolean $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pui : public int 方法声明\r\n```java\r\npublic int $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pus : public String 方法声明\r\n```java\r\npublic String $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pusb : public static boolean 方法声明\r\n```java\r\npublic static boolean $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### pusi : public static  int 静态方法声明\r\n```java\r\npublic static int $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n### puss : public static String 方法声明\r\n```java\r\npublic static String $VAR1$($VAR2$){\r\n    $END$;\r\n}\r\n```\r\n## 注释模板\r\n### multicomment ：多行注释\r\n```java\r\n/**\r\n * 描述: $END$\r\n * 日期: $DATE$ $TIME$ \r\n * 作者: 梁山广\r\n */\r\n ```\r\n ### singlecomment : 单行注释\r\n ```java\r\n // $END$ by 梁山广 at $DATE$ $TIME$ \r\n ```\r\n \r\n ## 自动生成时间戳的设置($DATE$ 和 $TIME$)\r\n ![自动生成时间戳的设置][1]\r\n\r\n\r\n  [1]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-IDEA%E5%BF%AB%E9%80%9F%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90--1515222173160.jpg', '2018-01-05 21:48:47', '利用IDEA编辑器自带的Live Templates可以极大地提高编程效率,比如快速完成属性、方法、注释、插入时间戳,Postfix可以快速完成常见的for循环、异常捕获、非空判断等等.在此把自己的经验总结下', 'http://img.blog.csdn.net/20161013150532137', '原创', b'1', b'1', b'1', ' IDEA 下Java快速代码生成', '2018-01-06 16:53:24', '39', '1', '1', b'1'), ('29', b'1', b'1', '## 类头注释\r\n+ 打开file->setting->Editor->Filr and Code Templates->Includes->File Header ,直接在右边的文件框里编辑你说需要注释的东西，然后应用保存之后,当你创建类的时候就会自动生成注释。\r\n![类注释](http://img.blog.csdn.net/20161013144235558)\r\n\r\n## 方法注释\r\n+ 打开file->setting->Editor->LiveTemplates点击右边上面那个绿色的+号，选择Template Group双击，然后弹出一个窗口，随便添加一个名字，我这里添加的是MyGroup然后点击OK\r\n![方法注释](http://img.blog.csdn.net/20161013145113147 \"方法注释\")\r\n+ 还是在file->setting->Editor->LiveTemplates这个路径下点击一下刚刚你添加的那个名字（我这是MyGroup），然后点击右边上面那个绿色的+号，选择LiveTemplate双击，填写下面的图上的框 \r\n![](http://img.blog.csdn.net/20161013145852869)\r\n+ 然后点击\r\n![](http://img.blog.csdn.net/20161013150017182)\r\n+ 然后选择Everywhere\r\n![](http://img.blog.csdn.net/20161013150219245)\r\n+ 最后点击右下角的Edit variables 按钮，然后弹出一个窗口，如下： \r\n![](http://img.blog.csdn.net/20161013150532137)\r\n+ 如果想把 @param：每一个参数可以这样 \r\n![](http://img.blog.csdn.net/20161202130929702)\r\n+ 参数值要自己写的\r\n```groovy\r\n groovyScript(\"def result=\'\'; def params=\\\"${_1}\\\".replaceAll(\'[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]\', \'\').split(\',\').toList(); for(i = 0; i < params.size(); i++) {result+=\' * @param \' + params[i] + ((i < params.size() - 1) ? \'\\\\n\\\\b\' : \'\')}; return result\", methodParameters())\r\n```\r\n+ 把这个添加进去，但是还要注意一点： \r\n![](http://img.blog.csdn.net/20161202131406143)\r\n+ 下面红色圈中的下拉框选择相对应的参数点击OK \r\n再点击apply,点击Ok。 \r\n然后写方法之前点写上add（刚刚填的）按tab，注释就出来了。\r\n\r\n', '2018-01-05 22:13:23', 'Intellij IDEA中利用Live Templates生成类注释和方法注释,教程很实用.关键是能生成时间戳', 'http://img.blog.csdn.net/20161013150532137', '转载', b'1', b'1', b'1', ' IntelliJ设置类头注释和方法注释(含时间戳)', '2018-01-06 00:31:40', '18', '1', '1', b'0'), ('30', b'1', b'1', '---\r\ntitle: 2018-1-6-个人博客、博客园、微信公众号、Github、本地同步写博客\r\ntags: Markdown,教程,同步\r\n\r\n---\r\n\r\n> 全篇教程是利用Markdown神器--小书匠进行串联地，墙裂推荐大家使用\r\n\r\n[Toc]\r\n\r\n### 1.写博客\r\n下载[小书匠][1]，关于Markdown的语法此处不再介绍。\r\n点击新建，创建自己的第一篇博客。\r\n\r\n![小书匠Markdown编辑器][2]\r\n\r\n\r\n![小书匠介绍][3]\r\n### 2.发布到博客园\r\n> 前提:自己去博客园主页注册下\r\n\r\n点击左上角的“小书匠”三个字，进入配置区，配置好自己的博客园地址、用户名、密码，然后点击发布即可。然后去自己的博客园主页就能看到发布的文章了\r\n\r\n\r\n![发布博客到博客园][4]\r\n  \r\n  ### 3.发布到自己的博客\r\n  > 把Mardown文件内容复制过去就行了\r\n  \r\n  ![发布到自己的博客][5]\r\n  \r\n  见我的博客:[我的博客地址][6]\r\n  \r\n  ### 4.同步到Github\r\n  点击左上角的“小书匠”三个字，进入配置区,点击绑定，按照里面的教程配置好数据存储和图床，各为自己Github上的Repo即可\r\n \r\n![enter description here][7]\r\n  \r\n  配置好后，在小书匠中添加图片时会自动加入到图床Repo中到Github中并取回URL，\r\n  \r\n  写完博客，点击另存为，选择前面配置好的Github上的Repo下的目录\r\n  \r\n  博客md文件会自动存到另一个博客的Repo中\r\n  \r\n### 5.博客发布到自己的微信公众号中\r\n微信公众号的排版问题一直很受人诟病，虽然有Mardown Here一类的插件，但是仍然很麻烦，这里一个很简单的方法是直接去博客园的后台博客管理页面，把前面发布的博客内容直接拷贝到微信公众号的编辑界面里，所有样式都能完整保存！！！\r\n\r\n![博客园样式完整复制到微信公众号][8]\r\n\r\n![enter description here][9]\r\n\r\n\r\n  [1]: http://soft.xiaoshujiang.com/download.html\r\n  [2]: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515240811611&di=c953882348f1bd2ff840c9a25593423f&imgtype=0&src=http://down.52pk.com/uploads/170710/5000_164015_1_lit.jpg\r\n  [3]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1728-%E5%B0%8F%E4%B9%A6%E5%8C%A0.png \"2018-01-06_1728-小书匠\"\r\n  [4]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1733-%E5%B0%8F%E4%B9%A6%E5%8C%A0%E5%8F%91%E5%B8%83%E5%88%B0%E5%8D%9A%E5%AE%A2%E5%9B%AD.png \"2018-01-06_1733-小书匠发布到博客园\"\r\n  [5]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1752-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.png \"2018-01-06_1752-自己的博客\"\r\n  [6]: http://liangshanguang.wang/\r\n  [7]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1757-%E5%B0%8F%E4%B9%A6%E5%8C%A0%E5%88%A9%E7%94%A8Github%E5%BD%93%E5%9B%BE%E5%BA%8A%E5%92%8C%E5%8D%9A%E5%AE%A2%E5%AD%98%E5%82%A8.png \"2018-01-06_1757-小书匠利用Github当图床和博客存储\"\r\n  [8]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1825--%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%B8%AD.png \"2018-01-06_1825--博客园复制到微信公众号中\"\r\n  [9]: https://www.github.com/19920625lsg/imgsave/raw/master/2018%E5%B9%B41%E6%9C%88/6%E6%97%A5%E5%8D%9A%E5%AE%A2-2018-1-6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E3%80%81%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%81Github%E3%80%81%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E5%86%99%E5%8D%9A%E5%AE%A2--2018-01-06_1827--%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%A0%B7%E5%BC%8F%E5%AE%8C%E7%BE%8E%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png \"2018-01-06_1827--博客园样式完美复制到微信公众号\"', '2018-01-06 18:42:55', '常用的写博客方式博客园、微信公众号、个人博客很难统一，而且免费图床几乎没有，自己好好研究下了，找了个给予Github托管的写博客方式。', 'http://img.25pp.com/uploadfile/app/icon/20160707/1467861288876739.jpg', '原创', b'1', b'1', b'1', '全渠道同步写博客的技巧', '2018-01-06 18:44:05', '14', '17', '1', b'0'), ('31', b'1', b'1', '> 在人间有谁活着不是一场炼狱\r\n\r\n今天，离我16年7月7日入职整整过去一年半了，猛地发现自己正处于人生中最尴尬的时期，\r\n不再享有新员工的犯错权，也步入了催房催婚催孩子的时期，\r\n职场遇到发展的瓶颈和迷茫，越来越多人的亲人朋友依托和寄希望于你，\r\n周围的浮躁和喧嚣让你想不清自己到底想要什么，看到同龄人买房、买车、结婚、晋升总会陷入痛苦的比较与自卑，\r\n周围人讨论的永远都是房子、车子、孩子、股票、分红、八卦……\r\n越来越体会到这个社会的阶级壁垒远比你想象地要厚且令人绝望。\r\n在人间有谁活着不是一场炼狱，然而仍然要不断抗争下去，你好，2018\r\n', '2018-01-07 14:17:22', '毕业很久了，感慨颇多', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515315894127&di=46572f57447b0b9326a173999b6cfbc5&imgtype=0&src=http%3A%2F%2Fupload.71.cn%2F2016%2F0728%2F1469675540696.jpg', '原创', b'1', b'1', b'1', '毕业一年半', '2018-01-12 00:10:04', '18', '11', '1', b'1'), ('32', b'1', b'1', '> int *pi=&a; printf(\"%d\\n\",*pi); 打印的是a的值，而不是&a\r\n\r\n###  先看下面一段代码\r\n```c\r\nint a=50;\r\nint b=60;\r\nint *pi=&a;\r\nprintf(\"%d\\n\",*pi);\r\npi=&b;\r\nprintf(\"%d\\n\",*pi);\r\nprintf(\"%d\\n\",pi);\r\n```\r\n### 结果是：\r\n\r\n```bash\r\n50\r\n60\r\n2686708\r\n```\r\n### 常有的疑惑\r\n* **第7行和第9行的赋值方式看起来不一样，为啥都能取到值？>第7行和第9行的赋值方式看起来不一样，为啥都能取到值？ 第8行的*pi不该是&a值吗？**\r\n### 解惑\r\n + `java int *pi=&a`其实等效于```(int *)pi=&a```,含义是：给int指针类型的变量pi赋值为a的地址。\r\n + `pi=&b`含义：给int指针类型的变量pi重新赋值为b的地址。可见和上面的含义是完全一致地\r\n + 之所以会有上面的疑惑，是因为误把`(int *)pi`和`*pi`中的`*`看成一个含义了。其实两者是完全不同地：前者是声明pi的类型为指针类型；后者时取pi中的地址指针指向的元素的值。pi本身存储的是a的地址，所以控制台输出的是a的地址值即2686708\r\n', '2018-01-10 14:40:15', '(int *)pi 和 *pi 千万别混啊.....', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515576301772&di=e58be9ad53b755955d37f4ba672a457e&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D1962452276%2C4074126980%26fm%3D214%26gp%3D0.jpg', '原创', b'1', b'1', b'1', '指针变量初始化赋值与使用的区别', '2018-01-11 22:39:47', '63', '4', '1', b'1'), ('34', b'1', b'1', ' >我辈生，生有所信；我辈死，死得其所。不苟活而生，唯信念而死！\r\n \r\n 知章骑马似乘船，眼花落井水底眠。\r\n\r\n 汝阳三斗始朝天，道逢麴车口流涎，恨不移封向酒泉。\r\n\r\n 左相日兴费万钱，饮如长鲸吸百川，衔杯乐圣称避贤。\r\n\r\n 宗之潇洒美少年，举觞白眼望青天，皎如玉树临风前。\r\n\r\n 苏晋长斋绣佛前，醉中往往爱逃禅。\r\n\r\n 李白斗酒诗百篇，长安市上酒家眠，天子呼来不上船，自称臣是酒中仙。\r\n\r\n 张旭三杯草圣传，脱帽露顶王公前，挥毫落纸如云烟。\r\n\r\n 焦遂五斗方卓然，高谈雄辩惊四筵。\r\n\r\n\r\n\r\n', '2018-01-12 00:19:18', '我辈生，生有所信；我辈死，死得其所。不苟活而生，唯信念而死！', 'https://i.loli.net/2018/01/12/5a5796722f148.png', '原创', b'1', b'1', b'1', '《饮中八仙歌》', '2018-01-12 00:59:40', '19', '18', '1', b'1'), ('35', b'1', b'1', '>人们常常怀念那些过去的事，不是因为它有多美好，而是它再也回不来了\r\n\r\n莺啼啼不尽，任燕语、语难通。这一点间愁，十年不断，恼乱春风。重来故人不见，但依然、杨柳小楼东。记得同题粉壁，而今壁破无踪。 \r\n\r\n兰皋新涨绿溶溶。流恨落花红。念着破春衫，当时送别，灯下裁缝。相思谩然自苦，算云烟、过眼总成空。落日楚天无际，凭栏目送飞鸿。\r\n\r\n', '2018-01-12 00:39:02', '人们常常怀念那些过去的事，不是因为它有多美好，而是它再也回不来了', 'http://5b0988e595225.cdn.sohucs.com/images/20170730/89e95840a8fd4f68820e842ec4900f07.jpeg', '原创', b'1', b'1', b'1', '《木兰花慢·莺啼啼不尽》', '2018-01-12 20:57:00', '13', '18', '1', b'1'), ('36', b'1', b'1', '+ i-当前光标前面插入字符 a-当前光标后面插入字符\r\n\r\n+ esc-返回命令模式 :wq-保存退出\r\n\r\n+ shift+a-跳到末尾插入字符 shift+i-行首\r\n\r\n+ o-当前行下面开一行插入字符 shift+o-上一行\r\n\r\n+ 光标一到某个位置按x删除\r\n\r\n+ 命令模式下按两次d删除整行', '2018-01-12 11:05:31', 'vim下的常用指令', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515736373838&di=bec4302b533b3ba9704002e6a18d948f&imgtype=jpg&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D2076193515%2C624247639%26fm%3D214%26gp%3D0.jpg', '原创', b'1', b'1', b'1', 'Vim常用指令', '2018-01-12 11:05:31', '3', '8', '1', b'1'), ('37', b'1', b'1', '```c++\r\n /*************************************************************************************\r\n     *****c++类的实现应该是在\".h\"文件中声明后在.cpp文件中用“返回值 类名::函数名...”来实现**\r\n     ************************************************************************************/\r\n\r\n    int myStringExtension::getInt(std::string str) {\r\n        int num = 0;\r\n        std::stringstream os;\r\n        os << str;\r\n        os >> num;\r\n        return num;\r\n    }\r\n\r\n    std::string myStringExtension::getString(int num) {\r\n        std::string str;\r\n        std::stringstream os;\r\n        os << num;\r\n        os >> str;\r\n        return str;\r\n    }\r\n\r\n    std::string myStringExtension::getTrim(std::string str) {\r\n        str.erase(0, str.find_first_not_of(\" \"));\r\n        str.erase(str.find_last_not_of(\" \") + 1);\r\n        return str;\r\n    }\r\n```', '2018-01-12 20:40:22', '目前有字符串转整型、整型转字符串、trim', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2774751207,3568559995&fm=27&gp=0.jpg', '原创', b'1', b'1', b'1', '基于STL封装自己的字符串操作类', '2018-01-12 20:41:55', '3', '4', '1', b'1'), ('38', b'0', b'1', '> 在这个不美好的世上，最美好的童话总是悲伤地，她们都是用饱受自我牺牲的崇高和孤独所折磨的灵魂写成地，满溢着无边的悲寂感，透明而凄美，原原本本地展现出生命本身的重量\r\n\r\n> 我们在属于自己的那座城里筑梦，不求闻达于世，但终究还是希望可以留下点什么，或许仅仅是为了被某个人偶然地想起\r\n\r\n>凡心所向，素履所往，生如逆旅，一苇以航。<br>\r\n稣合于言，安之若素。自言自语，无喜无悲。<br>\r\n凡心所向，素履所往，生如逆旅，一苇以航。<br>\r\n三月桃花，四月欢唱，两人一马，明日故乡。<br>\r\n流浪陌路，暖然绯凉，写意人生，相识一场。<br>\r\n不关此世，不负己心，我自倾杯，且君随意。\r\n\r\n> 不安于心，不困于情。不畏将来，不念过往。如此，安好。', '2018-01-12 20:55:23', '在这个不美好的世上，最美好的童话总是悲伤地', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516367209&di=64857504a35daf94eaebdc443933c1f8&imgtype=jpg&er=1&src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201609%2F03%2F20160903233848_BzyxF.thumb.700_0.jpeg', '原创', b'1', b'1', b'1', '美好的童话总是悲伤地', '2018-01-12 21:46:13', '18', '17', '1', b'1'), ('39', b'0', b'1', '参考自知乎：[在 Mac OS X 中怎样获取当前文件夹的路径？](https://www.zhihu.com/question/22883229/answer/22956721)\r\n\r\n## 快捷键\r\n使用 `command+option+c`即可把当前文件（夹）的路径复制到粘贴板中\r\n## 更好：在Finder最上面显示当前文件件路径\r\n+ 打开终端，输入下面的命令：\r\n```bash \r\ndefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\r\n```\r\n+ 就能在顶部看见完整的地址了\r\n![在Finder最上面看到地址](https://pic4.zhimg.com/50/031824973905702098e296e7352eb679_hd.jpg)\r\n+ 在Finder顶端的地址栏右键，还可以直接访问路径中的任意一层\r\n![还可以右键跳到任何一层](https://pic1.zhimg.com/50/64e6693cb7cae3bca2d0e41379d8c5fa_hd.jpg)\r\n\r\n\r\n', '2018-01-14 13:25:39', 'mac访问、复制当前路径', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1516512282&di=c51e03a2b9d09a132c7453dc3db34db2&imgtype=jpg&er=1&src=http%3A%2F%2Fimages.apple.com%2Fv%2Fmac%2Fhome%2Fq%2Fhome%2Fimages%2Faccessories_mac_large_2x.jpg', '转载', b'1', b'1', b'0', 'Mac中获取当前文件夹的路径', '2018-01-14 13:27:04', '3', '19', '1', b'0');
COMMIT;

-- ----------------------------
--  Table structure for `t_blog_tags`
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`),
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`),
  CONSTRAINT `FK5feau0gb4lq47fdb03uboswm8` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`),
  CONSTRAINT `FKh4pacwjwofrugxa9hpwaxg6mr` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_blog_tags`
-- ----------------------------
BEGIN;
INSERT INTO `t_blog_tags` VALUES ('4', '3'), ('8', '7'), ('10', '8'), ('19', '8'), ('21', '9'), ('25', '1'), ('29', '12'), ('28', '12'), ('30', '12'), ('32', '15'), ('31', '14'), ('34', '16'), ('36', '3'), ('37', '12'), ('35', '17'), ('26', '1'), ('38', '19'), ('39', '21');
COMMIT;

-- ----------------------------
--  Table structure for `t_comment`
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin` bit(1) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`),
  KEY `FK4jj284r3pb7japogvo6h72q95` (`parent_comment_id`),
  CONSTRAINT `FK4jj284r3pb7japogvo6h72q95` FOREIGN KEY (`parent_comment_id`) REFERENCES `t_comment` (`id`),
  CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_comment`
-- ----------------------------
BEGIN;
INSERT INTO `t_comment` VALUES ('6', b'1', 'https://avatars2.githubusercontent.com/u/16741594?s=400&u=a7818e7cf3899c4b796c82bf8de8f2dab864554a&v=4', '自己写的Linux总结', '2017-12-30 16:23:55', 'liangshanguang2@gmail.com', '梁山广', '4', null), ('7', b'1', '/images/me.jpg', '未来不易，加油努力', '2017-12-31 00:12:59', 'liangshanguang2@gmail.com', '梁山广', '21', null), ('8', b'1', '/images/me.jpg', '希望能保持初心，再接再厉', '2017-12-31 00:13:27', 'liangshanguang2@gmail.com', '梁山广', '21', '7'), ('16', b'1', '/images/me.jpg', '算法第四版-第二章第4节', '2018-01-03 18:31:16', 'liangshanguang2@gmail.com', '梁山广', '25', null), ('17', b'1', '/images/me.jpg', '愿未来更好', '2018-01-12 00:10:28', 'liangshanguang2@gmail.com', '梁山广', '31', null);
COMMIT;

-- ----------------------------
--  Table structure for `t_tag`
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_tag`
-- ----------------------------
BEGIN;
INSERT INTO `t_tag` VALUES ('1', '算法第四版'), ('2', '算法导论'), ('3', 'Linux基础'), ('4', '设计模式之禅'), ('5', 'Tensorflow'), ('6', 'Caffe'), ('7', '加解密'), ('8', '文件操作'), ('9', '真话与两级'), ('12', '教程'), ('13', '林肯传'), ('14', '毕业一年半'), ('15', 'C指针'), ('16', '唐诗'), ('17', '宋词'), ('18', '摘抄'), ('19', 'Life'), ('21', 'Mac OS');
COMMIT;

-- ----------------------------
--  Table structure for `t_type`
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_type`
-- ----------------------------
BEGIN;
INSERT INTO `t_type` VALUES ('1', 'Java'), ('2', '算法'), ('3', '机器学习'), ('4', 'C/C++'), ('8', '其他'), ('9', '设计模式'), ('10', '数据库'), ('11', '生活'), ('13', 'Python'), ('17', '阅读'), ('18', '诗词'), ('19', '工具');
COMMIT;

-- ----------------------------
--  Table structure for `t_user`
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `t_user`
-- ----------------------------
BEGIN;
INSERT INTO `t_user` VALUES ('1', '/images/me.jpg', '2017-12-07 21:47:16', 'liangshanguang2@gmail.com', '梁山广', '940C0288D9B21981F667762FD1C3C021', '1', '2017-12-07 21:48:17', '梁山广');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
